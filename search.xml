<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F09%2FAndroid%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android 内存管理内存管理的目的就是我们在开发中怎么有效的避免我们的应用程序出现内存泄露问题。内存泄露简短粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不被使用，导致 GC 不能回收。 Java 内存分配策略Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配。对应的三种存储策略使用的内存空间主要分别是静态存储区（方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态数据，全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。 栈区：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因此栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区：又称动态内存分配，通常就是在程序运行时直接 new 出来的内存，也就是对象的实例。这部分内存在不使用时，将会由 Java 垃圾回收器负责回收。 堆与栈的区别：在方法体内定义的（局部变量）一些基本类型的变量和对象的引用都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。 堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊变量，这个变量的取值等于数组或者对象在内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。 举例： 123456789101112public class Sample &#123; int s1 = 0; Sample sample1 = new Sample(); public void method () &#123; int s2 = 1; Sample sample2 = new Sample(); &#125;&#125;Sample sample3 = new Sample(); Sample 类的局部变量 s2 和引用变量 sample2 都是存在于栈中，但 smaple2 指向的对象是存在于堆中。 sample3 指向的对象存放在堆中，包括这个对象的所有成员变量 s1 和 sample1， 而它自己存在与栈中。 结论： 局部变量的脚本数据类型和引用存储在栈中，引用的对象实体存储于堆中。—— 因为他们属于方法中的变量，生命周期随方法而结束 成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）。—— 因为他们属于类，类对象终究是要被 new 出来使用的。 Java 是如何管理内存Java 的内存管理就是对象的分配和释放的问题。在 Java 中，coder 需要通过关键字 new 为每一个对象申请新的存储空间（基本类型除外），所有的对象都在 堆（Heap）中分配空间。另外对象的释放是由 GC 决定和执行的，在 Java 中，内存分配是由 coder 完成的，而内存释放是由 GC 完成的。这种收支两条线的方法简化了 coder 的工作。同时也加重了 JVM 的工作。也是 Java 程序运行速度慢的原因之一。因为 GC 为了能够正确释放对象， GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要监控。 监控对象状态是为了更准确、及时地释放对象，而释放对象的根本原则就是该对象不在被引用。 Java 使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要他们和根进程不可达，那么 GC 就可以回收他。这种管理方式的有点是管理内存的精度高，但是效率低。 什么是 Java 中的内存泄露在 Java 中，内存泄露就是存在一些被分配的对象，这些对象有两个特点。 这些对象是可达的，即在有向图中，存在通路与其相连 这些对象是无用的，即程序以后不会在使用这些对象。 如果满足这两个条件，这些对象就可以判定为 Java 中的内存泄露，这些对象不会被 GC 回收，但却是占用着内存。 对于程序猿来说， GC 基本是透明的，不可见的。虽然我们只有几个函数可以方位 GC， 例如运行 GC 的函数 System.gc()，但是根据 Java 语言规范定义，该函数不保证 JVM 的垃圾回收器一定会执行。因为，不同的 JVM 实现着可能使用不同的算法管理 GC。 通常 GC 的线程优先级比较低。 JVM 调用 GC 的策略也有很多种，有的是内存使用达到一定成都时， GC 才开始工作；也有定时执行，有的是平缓执行 GC， 有的是中断式执行 GC。 通常来说，我们不需要关心这些。除非在一些特定的场合， GC 的执行影响应用程序的性能，例如对于基于 Web 的实时系统，如网络游戏等，用户不希望 GC 突然终端应用程序执行而进行垃圾回收，那么我们需要调整 GC 的参数，让 GC 能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行， Sun 提供了 HotSpot JVM 支持这一特性。 同样给出一个 Java 内存泄露的典型例子 123456Vector v = new Vector(10);for (int i = 1; i &lt; 100; i++) &#123; Object o = new Object(); v.add(o); o = null;&#125; 在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然应用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。 详细的 Java 中的内存泄露Java 内存回收机制不论那种语言的内存分配方式，都需要返回所分配的真实地址，也就是返回一个指针到内存块的首地址。Java 中对象是采用 new 或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的。所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成。 GC 为了能够正确释放对象，会监控每个对象的运行状态，对他们的申请、引用、被引用、赋值等状况进行监控， Java 会使用有向图的方式进行管理内存，实时监控对象是否可以到达，如果不可以到达，则将其回收，这样也可以消除引用的循环问题。在 Java 语言中，判断一个内存空间是否符合垃圾回收标准有两个： 1. 给对象赋予了空值 null 2. 给对象赋予了新值，这样重新分配了内存空间。 Java 内存泄漏引起的原因内存泄露是指无用对象（不再使用的对象）持续占有内存活无用对象的内存得不到及时释放，从而造成内存空间的浪费称为内存泄漏。内存泄漏有时不严重，不易察觉，这样开发者就不知道存在内存泄漏，但有时也很严重，会提示 Out of memory。 Java 内存泄漏的根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被释放回收，这就是 Java 中内存泄漏的发生场景，主要有一下几大类： 静态集合类引起的内存泄漏： 像 HashMap、Vector 等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象 Object 也不能被释放，因为他们也将一直被 Vector 等引用着。 例如： 123456Static Vector v = new Vercor(10);for (int i = 1; i &lt; 100; i++) &#123; Object o = new Object(); v.add(o); o = null;&#125; 在这个例子中，循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果仅仅释放引用本身（o = null），那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可会说的。因此对象加入到 Vector 后， 还必须从 Vector 中删除，最简单的是将 Vector 设置为 null。 当集合里面的对象属性被修改后，再调用 remove() 方法时，不起作用 例如： 12345678910111213141516171819202122public static void main(String[] args) &#123; Set&lt;Person&gt; set = new HashSet&lt;Person&gt;(); Person p1 = new Person("唐僧", "pwd1", 25); Person p2 = new Person("孙悟空", "pwd2", 24); Person p3 = new Person("猪八戒", "pwd3", 26); set.add(p1); set.add(p2); set.add(p3); System.out.println("总共有：" + set.size() + " 个元素");// 结果： 总共有 3 个元素 p3.setAge(2); // 修改 p3 的年龄，此时 p3 元素对应的 hashcode 值发生改变 set.remove(p3); // remove 掉，造成内存泄露 set.add(p3); // 重新添加，成功 System.out.println("总共有：" + set.size() + " 个元素"); // 结果：总共有 4 个元素 for (Person person : set) &#123; System.out.println(person); &#125;&#125; 监听器 在 Java 变成中，我们需要和监听器打交道，通常一个应用当中会有多个监听器，我们会调用一个控件的例如addXXXXListener() 等方法来增加监听器，但往往在释放对象的时候，却没有记住去删除这些监听器，从而增加了内存泄漏的机会。 各种连接 比如数据库连接（dataSourse.getConnection()）、 网络连接(socket) 和 io 连接，除非其显示的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的。对于 Resultset 和 Statement 对象可以不进行显示回收，但 Connection 一定要显示回收，因为 Connection 在任何时候都无法自动回收，而 Connection 一旦回收， Resultset 和 Statement 对象就会立即2为 NULL。 但是如果使用连接池，情况就不一样了，除了要显示地关闭链接，还必须显示地关闭 Resultset 和 Statement 对象（关闭其中一个， 另外一个也会关闭），否则就会造成大量的 Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在 try 里面去连接，在 finally 里面释放连接。 内部类和外部模块的引用 内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后续类对象没有释放。此外 coder 还要小心外部模块不经意的引用，例如 coder A 负责 A 模块，调用了 B 模块的一个方法： public void registerMsg(Object b); 这种调用就要小心，传入了一个对象，很可能模块 B 就保持了对该对象的引用，这时候就需要注意模块 B 是否提供响应的操作去除引用。 单例模式 不正确的使用单例模式是引起内存泄漏的一个常见问题，单利对象在初始化后，将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。 12345678910111213141516171819202122class A &#123; public A () &#123; B.getInstance().setA(this); &#125; ...&#125;// B 采用单例模式class B &#123; private A a; private static B instance = new B(); private b ()&#123;&#125; public static B getInstance()&#123; return instacne; &#125; public void setA (A a) &#123; this.a = a; &#125; // .........&#125; 显然 B 采用 singleton 模式， 它持有一个 A 对象的引用，而这个类的对象将不能被回收。想象下如果 A 是个比较复杂的对象或者集合类型会发生什么。 Android 中常见的内存泄漏汇总集合类泄漏集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量（比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它），那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的例子中就是其中一种情况，当然实际上我们在项目中肯定不会这样谢代码，但稍不注意还是很容易出现这种情况。 单例造成的内存泄露由于单利的静态特性使得其生命周期跟应用一样长，所以如果使用不恰当的话，很容易造成内存泄漏。 12345678910111213public class AppManager &#123; private static AppManager instance; private Context context; private AppManager(Context context) &#123; this.connect = connect; &#125; public static AppManager getInstance(Context context) &#123; if (instance == null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 Context， 所以这个 Context 的生命周期的长短至关重要： 如果此时传入的是 Application 的 Context， 因为 Application 的生命周期就是这个应用的生命周期，所以这将没有任何问题。 如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的应用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时，它的内存并不会被释放，就会造成泄漏。 正确的方式应修改为： 1234567891011121314public class AppManager &#123; private static AppManager instance; private Context context; private AppManager (Context context) &#123; this.context = context.getApplicationContext();// 使用 Application 的 context &#125; public static AppManager getInstance(Context context) &#123; if (instance == null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 或者这样写，连 Context 都不用传进来： 12345678910111213141516171819202122232425262728293031在你的 Application 中添加一个静态方法， getContext() 返回 Application 的 context...context = getApplicationContext();.../** * 获取全局的 Context * @return 返回全局的 context 对象 */ public static Context getContext()&#123; reutnr context;&#125;public class AppManager &#123; private static AppManager instance; private Context context; private AppManager () &#123; this.context = MyApplication.getContext();// 使用 Application 的 context &#125; public staitc AppManager getInstance() &#123; if (instance == null) &#123; instance = new AppManager(); &#125; return instance; &#125;&#125; 匿名内部类/非静态内部类和异步线程非静态内部类创建静态实例造成的内存泄漏 有的时候我们可能会在启动频繁的 Activity 中，为了避免重复创建相同资源，可能会出现这种写法 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; private staitc TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mResource == null) &#123; mResource = new TestResource(); &#125; //.... &#125; class TestResource &#123; //.... &#125;&#125; 这样就在 Activity 内部创建了一个非静态内部类的单例，每次启动 Activity 都会使用该单利的数据，这样虽然避免了资源的重复创建，不过这种写法却造成了内存写泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态实例，该实例的生命周期和应用一样长，这就导致了该静态实例一直会持有该 Activity 的引用，导致 Activity 的内存资源不能正常回收。正确的做法： 将该内部类设为静态内部类或者将该内部类抽取出来封装成单例，如果需要使用 Context， 按照上一个方法推荐使用 Application 中的 Context。 当然 Application 的 Context 不是万能的，所以也不能随便乱用，对于有些地方则是必须使用 Activity 的 Context ，对于 Application，Service， Activity 三者的 Context 的应用场景如下： 其中：NO1 表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建。 匿名内部类Android 开发经常会继承实现 Activity/Fragment/View， 此时如果你使用了匿名类，并被异步线程持有，如果没有任何措施这样一定会导致泄漏 1234567891011public class MainActivity extends Activity &#123; ... Runnable ref1 = new MyRunnable(); Runnable ref2 = new Runnable ()&#123; @Override public void run() &#123; .... &#125; &#125;; ...&#125; ref1 和 ref2 的区别是， ref2 使用了匿名内部类。我们看一下运行时，这两个引用的内存： 可以看到 ref1 没什么特别的。 但 ref2 这个匿名类的实现对象里面多了一个引用： this$0 这个引用指向 MainActivity.this， 也就是说当前的 MainActivity 实例会被 ref2 持有，如果将这个引用再传入一个异步线程，此线程和此 Activity 生命周期不一致的时候，就会造成内存泄漏。 Handler 造成的内存泄漏Handler 的使用造成的内存泄漏问题应该说是最常见的，但很多时候我们为了避免 ANR 而不在主线程中进行耗时操作，在处理网络任务或者封装一些请求回调等 api 都借助 Handler 来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写不规范就有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。 由于 Handler 属于 TLS（Thread Local Storage）变量，生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，很容易导致无法正确释放。 1234567891011121314151617181920212223public class MainActivity extends Activity &#123; private final Handler mLeakyHandler = new Handerl()&#123; @Override public void handleMessage(Message msg) &#123; ... &#125; &#125;; @Override protected void onCreate(Bundler savedInstanceState) &#123; super.onCreate(savedInstanceState); // post a message and delay its execution for 10 minutes. mLeakHandler.postDelayed(new Runnable()&#123; @Override public void run()&#123; ... &#125; &#125;, 1000 * 6 * 10); // go back to the previous Activity finish(); &#125;&#125; 在该例中，生命了一个延时 10 分钟执行的消息 Message， mLeakyHandler 将其 push 进了消息队列 MessageQueue 中。当 Activity 被 finish() 掉，延时任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，此时 finish() 掉的 Activity 就不会被回收，从而造成内存泄漏（因 Handler 为非静态内部类，会持有外部类的引用，在这里就是 MainActivity）. 修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 生命为静态的，则其存活期和 Activity的 生命周期无关了，同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 Context 传入， 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SampleActivity extends Activity &#123; /** * Instence of static inner classes do not bold an implicit reference to their outer class */ private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler (SampleActivity activity) &#123; mActivity = new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage (Message msg) &#123; SampleActivity activity = mActivity.get(); if(activity != null) &#123; //.... &#125; &#125; &#125; private final MyHandler mHandler = new MyHandler(this); /** * Instance of anonymous classes do not hold an implicit * reference to their outer class when they are "static" */ private static final Runnable sRunnable = new Runnable () &#123; @Override public void run()&#123; ... &#125; &#125;; @Override protected void onCreate(Bundler savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 mintues. mHandler.postDelay(sRunnable, 1000 * 60 * 10); // go back to the previous Activity finish(); &#125; &#125; 综述， 即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。 前面提到的 WeakReference，所以这里简单说下 Java 中对象的几种引用类型。 Java 对引用分为 StrongReference， SoftReference， WeakReference和 PhantomReference 四种。 级别 回收时机 用途 生存时间 强(StrongReference) 从来不会 对象的一般状态 JVM 停止运行时终止 软(SoftReference) 在内存不足时 联合 ReferenceQueue 构造有效期短/占内存大/生命周期长的对象的二级高速缓冲器(内存不足才清空) 内存不足时终止 弱（WeakReference） 在垃圾回收时 联合 ReferenceQueue 构造有效期短/占内存大/生命周期长的对象的一级高速缓冲器(系统发生 gc 则清空) gc 运行后终止 虚（PhantomReference） 在垃圾回收时 联合 ReferenceQueue 来跟踪对象被垃圾回收器回收的活动 gc 运行后终止 在 Android 应用开发中，为了防止内存溢出，在处理一些占用内存大而且生命周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java 虚拟机就会把这个软引用加入到与之关联得的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清楚已失效的软/弱引用。 假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次去读取图片，由于读取文件需要硬件操作，速度很慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是由于图片占用空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生 OutOfMemery 异常。这时我们可以考虑使用软/弱引用技术来避免这个问题发生。以下是高速缓冲器的雏形： 首先定义一个 HashMap，保存软引用对象： 1private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;(); 再定义一个方法，保存 bitmap 的软引用到 HashMap。 123456789101112131415161718192021222324public class CacheBySoftRef &#123; // 先定义一个 HashMap，保存软引用对象 private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;(); // 再定义一个方法，保存 bitmap 的软引用到 HashMap。 public void addBitmapToCache(String path) &#123; // 强引用的 Bitmap 对象 Bitmap bitmap = BitmapFactory.decodeFile(path); // 软引用的 bitmap 对象 SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap); imageCache.put(path, softBitmap); &#125; // 获取的时候，可以通过 SoftReference 的 get() 方法得到 bitmap 对象 public Bitmap getBitmapByPath(String path) &#123; // 从缓存中取软引用的 bitmap 对象 SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path); // 判断是否存在软引用 if (softBitmap == null) return; // 通过软引用取出 bitmap 对象，如果由于内存不足 Bitmap 被回收，将取到空，如果未被回收，则可重复使用，提高速度 Bitmap bitmap = softBitmap.get(); return bitmap; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F08%2F06%2FJava%20%E5%90%84%E5%BC%95%E7%94%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java Reference(SoftReference, WeakReference, PhantomReference, StrongReference) 的使用Reference 引用继承自 Object， 有 SoftReference, WeakReference, PhantomReference 三个直接子类。 三个子类的构造方法中涉及到 ReferenceQueue 和 Referent： Referent： 被引用对象 ReferenceQueue：当引用（软引用、弱引用、虚引用）的 Referent 被回收后，该引用（软引用、弱引用、虚引用）会被 enqueue 到这个 ReferenceQueue 中。 123456789101112131415161718192021public class ReferenceTest&#123; public static void main(String[] args) &#123; &#125; static class Person &#123; private String name; private String getName()&#123; return name; &#125; private void setName(String name) &#123; this.name = name; &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println("in Person finalize"); &#125; &#125;&#125; StrongReference 强引用Java 中使用的最多，普通的引用 Object obj = new Object(); Person p = new Person(); 都属于强引用 强引用本身存储在栈中，new 出来的对象存储在堆中。栈中保存的引用指向堆中对象的地址。 一般情况下，当引用不在指向堆中对象的地址时（person = null） GC collector 就开始考虑对此内存（堆中的对象）进行回收。 1Person p = new Person(); person 就是一个强引用，强引用不会被 GC，即使内存不够抛出 OOM 时也不会被回收。 SoftReference 软引用软引用普通使用形式： 12Person p = new Person();SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person); 强引用 person 作为参数，创建了一个软引用对象 sr, 下面是例子： 12345678910111213141516171819202122private static void testSofeReference()&#123; // 创建强引用对象 Person person = new Person(); System.out.println("person 对象为" + person); // 创建软引用对象 SoftReference&lt;Person&gt; sr = new SoftReference&lt;Person&gt;(person); person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存(OOM 之前) if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.gc(); if(sr.get() == null)&#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125;&#125; 执行上面的例子： 123person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c 当执行 person = null 后，堆内存的 Person 对象不再有任何强引用指向它，但此时还存在 sr 引用的对象指向 Person 对象。此时调用 sr.get() 方法，返回 Person 对象，即之前堆中的强引用对象了。我们可以合理猜测GC collector 很有可能尚未进行垃圾回收，所以此时 sr.get() 方法返回不为空。 我们继续执行 System.gc() 强制进行垃圾回收，打印结果可以看到， sr.get() 返回依然不为空，说明 Person 对象依旧没有被回收。 软引用所指向的对象要进行回收，需要满足两个条件： 没有任何强引用指向软引用指向的对象（内存中的 Person 对象） JVM 需要内存时，即在抛出 OOM 之前 总结： SoftReference 变相延长了其只是对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收才回收此堆内存空间。 软引用还可以和一个 ReferenceQueue 一起使用， 当 SoftReference 的 Referent 被回收以后，这个 SoftReference 会被自动 enqueue 到这个 ReferenctQueue 中。 1234567891011121314151617181920212223242526private static void testSoftReferenceWithQueue()&#123; Person person = new Person(); System.out.println("person 对象为：" + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); SoftReference&lt;Person&gt; sr = new SoftReference&lt;&gt;(person, queue); person = null; // 之前 new 出的 Person 对象不会立即被回收，除非 JVM 需要内存 （OOM 前） if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.out.println("加入 ReferenceQueue 的对象为：" + queue.poll()); System.gc(); if(sr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + sr.get()); &#125; System.out.println("加入 ReferenceQueue 的对象为： " + queue.poll());&#125; 执行上述例子，结果如下： 12345person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c加入 ReferenceQueue 的对象为 nullperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8c加入 ReferenceQueue 的对象为 null 注意： 当 SoftReference 或 WeakReference 的 get() 方法返回 null 时，仅表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。 而只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。 WeakReference 弱引用弱引用的一般使用形式： 1234567891011121314151617181920private static void testWeakReference()&#123; Person person = new Person(); System.out.println("person 对象为： " + person); WeakReference&lt;Person&gt; wr = new WeakReference&lt;&gt;(person); person = null; // 被 GC 后，之前 new 出的 Person 对象会立即被回收，进入 GC 流程。 if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; System.gc(); if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125;&#125; 执行结果为： 1234person 对象为 com.example.ReferenceTest$Person@522d9d8cperson 对象尚未被回收 com.example.ReferenceTest$Person@522d9d8cperson 对象进入 GC 流程in Person finalize 当执行 person = null 后，堆内存的 Person 对象不再有任何引用指向它，但此时还存在 wr 引用的对象指向 Person 对象。 此时调用 wr.get() 方法，返回 Person 对象，即之前堆中的强引用对象，我们可以合理猜测 GC collector 很有可能尚未进行垃圾回收，所以此时 wr.get() 方法返回不为空。 继续执行 System.gc() 强制执行垃圾回收，打印结果可以看到，wr.get() 返回为空 “person 对象进入 GC 流程” ，且执行了静态内部类中的 finalize 方法。说明 Person 对象被回收，进入垃圾回收流程。 弱引用所指向的对象要进行回收，只需要满足条件： ​ 没有任何强引用指向弱引用指向的对象（内存中的 Person 对象） 总结： ​ WeakReference 不改变原有的强引用独享的垃圾回收机制，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。 其主要使用场景见于： ​ 当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收机制，此时 WeakReference 正好符合需求，常见于一些与生命周期的场景中，比如 Activity 中的 Handler 的使用，为了防止内存泄露需要用到弱引用。 与 SoftReference 一样，可以同 ReferenceQueue 一起使用。当 WeakReference 的 Referent 被回收以后，这个 WeakReference 会被自动 enqueue 到这个 ReferenceQueue 中。 1234567891011121314151617181920212223242526272829303132333435private static void testWeakReferenceWithQueue () &#123; Person person = new Person(); System.out.println("person 对象为 " + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); WeakReference&lt;Person&gt; wr = new WeakReference&lt;&gt;(person, queue); System.out.println("wr 对象为 " + wr); if (wr.get() == null) &#123; System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; System.out.println("Whether or not this reference has been enqueued:" + wr.isEnqueued()); System.out.println("Queue item: " + queue.pull()); System.gc(); if (wr.get() == null) &#123;// 仅是表名指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收，只有确认被垃圾回收后，如果有 ReferenceQueue ，其引用才会被放置于 ReferenceQueue 中。 System.out.println("person 对象进入 GC 流程"); &#125; else &#123; System.out.println("person 对象尚未被回收" + wr.get()); &#125; try &#123; // 确保垃圾回收线程能够执行 Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Whether or not this reference has been enqueued: " + wr.isEnqueued()); System.out.println("queue item: " + queue.poll());&#125; 执行结果： 123456789person 对象为 com.example.ReferenceTEst$Person@522d9d8cwr 对象为 java.lang.ref.WeakReference@603828d2person 对象尚未被回收 com.example.ReferenceTEst$Person@522d9d8cWhether or not this reference has been enqueued: falsequeue item: nullperson 对象进入回收流程in Person finalizeWhether or not this reference has been enqueued: truequeue item: java.lang.ref.WeakReference@603828d2 从第二行到最后行可以看出， person 进入 GC 流程后，wr 被加入到 queue 中。 注意： ​ 当 SoftReference 或者 WeakReference 的 get() 方法返回 null 时，仅表示其指示对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。 ​ 而只有确认被垃圾回收后，如果有 ReferenceQueue， 其引用才会被放置于 ReferenceQueue 中。 PhantomReference 虚引用虚引用源码： 1234567891011121314package java.lang.ref;import java.lang.ref.Reference;import java.lang.ref.ReferenceQueue;public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123; public T get()&#123; return null; &#125; public PhantomReference(T var1, ReferenceQueue&lt;? super T&gt; var2) &#123; super.(var1, var2); &#125;&#125; PhantomReference 只有一个构造函数 PhantomReference(T referenct, ReferenceQueue&lt;? super T&gt; q) 因此，PhantomReference 使用必须结合 ReferenceQueue； 不管有无强引用指向 PhantomReference 的指示对象， PhantomReference 的 get() 方法返回结果都是 null 举例： 1234567891011121314151617181920212223private static void testPhantomReference() &#123; Person person = new Person(); System.out.println("person 对象为" + person); ReferenceQueue&lt;Person&gt; queue = new ReferenceQueue&lt;&gt;(); PhantomReference&lt;Person&gt; pr = new PhantomReference&lt;&gt;(person, queue); System.out.println("pr 对象为" + pr); System.out.println("pr.get() = " + pr.get()); person = null; System.gc(); try&#123; // 确保垃圾回收线程执行 Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("queue item: " + queue.poll());&#125; 执行结果： 12345person 对象为 com.example.ReferenceTEst$Person@522d9d8cpr 对象为 java.lang.ref.PhantomReference@60e35b53pr.get() = nullin Person finalizequeue ite: java.lang.ref.PhantomReference@60e35b53 总结： ​ 与 WeakReference 一样，不改变原有的强引用对象的垃圾回收机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可以被垃圾回收。虚引用主要用来跟踪对象被垃圾回收后的活动（监听并才去必要的行动） 用途： ​ 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ​ 程序可以通过判断医用队列中是否已经加入虚引用来了解被引用的对象是否将要被垃圾回收。 ​ 程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前才去必要的行动。]]></content>
  </entry>
  <entry>
    <title><![CDATA[线程通信基础流程]]></title>
    <url>%2F2019%2F08%2F01%2FHandler%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] Android 中线程通信靠的就是 Handler、Looper、Message、MessageQueue 这四个。 Looper在 Looper 中，维持一个 Thread 对象以及 MessageQueue， 通过 Looper 的构造函数可以看出 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed);// 传入的参数代表这个 Queue 是否能够被退出 mThread = Thread.currentThread();&#125; Looper 在构造函数里做了两件事儿： 将线程对象指向了创建的 Looper 的线程 创建了一个新的 MessageQueue 分析完构造函数后，看下面两个方法 looper.loop() looper.prepare() looper.loop()在当前线程中启动一个 Message loop 机制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop()&#123; final Looper me = myLooper();// 获取当前线程绑定的 Looper if(me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn`t called on this thread"); &#125; final MessageQueue queue = me.mQueue();// 获取与 Looper 绑定的 MessageQueue // make sure the identity of this thread is that of the local process, // And keep track of what that identity token actuall is. Binder.clearCallingIdentity(); fianl long ident = Binder.clearCallingIdentity(); // 进入死循环，不断获取对象，分发对象到 Handler 中去消费 for(;;) &#123; Message msg = queue.next();// 不断获取下一个 message 对象，这里可能会造成阻塞。 if(msg == null) &#123; // No message idicates that the message queue is quittig. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if(logging != null) &#123; logging.println("&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback _ ": " + msg.what); &#125; // 在这里开始分发 Message msg.target.dispatchMessage(msg); if(logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the identity of the thread wasn`t corrupted. final long newIdent = Binder.clearCallingIdentity(); if(ident != null) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; // 当分发完 Message 后，当然要标记将该 Message 为 “正在使用” msg.recycleUnchecked(); &#125;&#125; 从上面的代码可以看出，最重要的方法是： queue.next() msg.target.dispatchMessage(msg) msg.recycleUnchecked() 其实 Looper 中最重要的部分都是由 Message、MessageQueue 组成的，这段代码设计到的四个对象，他们彼此的关系如下: MessageQueue： 装食物的容器 Message ：被装的食物 Handler （msg.target 实际上就是 Handler）：食物的消费者 Looper：负责分发食物的人 looper.prepare() 在当前线程关联一个 Lopper 对象12345678private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Lopper may be created per thread"); &#125; // 在当前线程绑定一个 looper mThreadLocal.set(new Looper(quiteAllowed));&#125; 在上面的代码中，做了两件事儿： 判断当前线程有没有 Looper，如果有则抛出异常（在这里我们就可以知道，Android 规定一个线程只能拥有一个与自己关联的 Looper。 如果有的话，那么就设置一个新的 Looper 到当前线程。 Handler 的使用1234567Handler handler = new Handler ()&#123; // @Override public void handleMessage(Message msg) &#123; // handle your message &#125;&#125; 我们先来看下 Handler 的构造： 12345678910111213141516// 空参构造与之对应public Handler(Callback callbacck, boolean async) &#123; // 大姨泄漏提醒log ... // 获取与创建 Handler 线程的 Looper mLooper = Looper.myLooper(); if(mLooper == null) &#123; throw new RunntimeException("Can`t create handler inside thread that has not called Looper.prepare()"); &#125; // 获取 Looper 绑定的 MessageQueue // 因为一个 Looper 只有一个 MessageQueue， 也就是与当前线程绑定的 MessageQueue mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; Looper.loop() 死循环中的 msg.target 是什么时候被赋值的？ handler.handleMessage(msg) 在什么时候被回调的？ A1: Looper.loop() 死循环中的 msg.target 是什么赋值的呢？要分析这个问题，自然的就想到从发送消息开始，无论是 handler.sendMessage(msg) 还是 handler.sendEmptyMessage(what)， 最后都可以追溯到下面这个方法： 1234567891011121314public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; // 引用 Handler 中的 MessageQueue // 这个 MessageQueue 就是创建 Looper 时被创建的 MessageQueue MessageQueue queue = mQueue; if(queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called withe no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; // 将新来的 Message 加入到 MessageQueue 中 return enqueueMessage(queue, msg, uptimeMillis);&#125; 接下来看一下 enququeMessage(queue, msg, uptimeMillis): 1234567private boolean enququeMessage(MessageQueue, queue, Message msg, long uptimeMillis) &#123; msg.target = this; if(mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; A2: handler.handleMessage(msg) 在什么时候被回调？通过上面的分析，我们很明确知道， Message 中的 target 是在什么时候赋值的，我们先来分析下在 Looper.loop() 中出现过的 dispatchMessage(msg) 方法 123456789101112public void diapatchMessage(Message msg) &#123; if(msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if(mCallback != null) &#123; if(mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); // 开始回调 &#125;&#125; 通过上面的分析，可以清楚的知道 Handler, Looper, Message, MessageQueue 这四者的关系以及如何合作了。 总结当我们调用 handler.sendMessage(msg)； 方法发送一个 Message 时， 实际上这个 Message 是发送到与当前线程绑定的一个 MessageQueue 中，然后与当前线程绑定的 Looper 将会不断的从 MessageQueue 中取出新的 Message， 调用 msg.target.dispatchMessage(msg) 方法将消息发送到与 Message 绑定的 handler.handleMessage() 方法中。 一个 Thread 对应多个 Handler， 一个 Thread 对应一个 Looper 和 MessageQueue， Handler 与 Thread 共享 Looper 和 MessageQueue。 Message 只是消息的载体，将会被发送到与线程绑定的唯一的 MessageQueue 中，并且被与线程绑定的唯一的 Looper 分发，被其自身绑定的 Handler 消费。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（三）]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[距离上一次更新已经过去一个半月了，请不要担心，他还在！作为绿植小白，真真切切的体验养殖的快乐、与惊心动魄的时候，是不会想起来要记录博客的。 这次写这篇文章的目的，依然还是要记录一下它的成长，遭遇，以及一些养殖过程中的经验。好啦，天也不早了，咱也得弄点干货了。 绿植小白，在上手清香木后，查询到的一些养殖的理论知识，在这一个半月的时间里得到了很严峻的挑战。继上次为它替换了新家之后，它就不在是从前的那个可爱的孩子了，淘气的狠；现在造的（东北话，本人东北滴，意思是将自己的身体，外表，或其他弄得破败不堪）还能可看出点模样来。 这段时间，它经历的掉叶、枯黄、旱涝。哈哈，你们有没有感觉到他很可怜。但不论怎样，他现在正在茁壮的成长中，已经逃离了法海。 现在的它，虽然已经没有了挡住的枝繁叶茂，但也没有像我这没程序员一样，寸草不生。那我们就接下来就还是说说它的养殖注意事项吧： 掉叶 掉叶是正常现象，在绿植更新新的环境，移植到新的盆中时，都会因需要对新环境的适应儿掉叶，过几天之后就好了，更换新盆后，将水浇透，静止几天（超过正常浇水周期），但也要考虑突然的蓄水能力以及土壤的潮湿程度。 黄叶 黄叶一般是发生在水分过大，导致根部腐烂时会发生，因此我在浇水时，要关注一下突然中水分的含量，适量且有规律的浇水，对绿植的发育是有好处的。 土壤 起初我的浇水频率是 3-5 天浇一次，但我发现他经常没有精神，蔫蔫的，每次浇水时，观察土壤都已经要干透了，然后我就改为 2-3 天浇水一次，慢慢的他比以前更加油绿，精神面貌更加挺拔。由此呢，总结下来土壤蓄水能力对植物的生长成正比关系，所以选择好的土壤，更有助于它的生长。目前它的土壤还是自从他来到我这里商家送的，土壤很稀松，杂质比较多，蓄水能力也一般，等到他在打一点，为他换一个新家的时候，会考虑给他换一个土壤。毕竟大自然的力量是很庞大的，也许那时他会成长为参天大树吧。 总结 总之，老话讲”有志者事竟成“，只要用了真心，就一定会有收获；不论是成功还是失败，我们都要将他看做是我们成功路上的经验，不骄不馁。 习惯是养成的，就像它一样，虽然它在那里，也不会同我讲话，也不会同我互动，就那样静静的看着我，而哪一天看不见它的时候，我也会很想它，有时也不吝自己的目光，多看几眼，只希望它能够拙长成长。]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（二）]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[心心切切,每天都会关注它的变化,可惜心急吃不得热豆腐;经过了几天, 发现它有一些枯叶和干枝,你是在向我宣战吗?????上网查询了一下发现其实是植物在更换了环境之后,需要一段时间的适应,枯叶干枝属于正常现象, 哈哈哈,还好你不是嫌弃我的小屋. 记得高中那会,每天都在书本的海洋里飘荡,生物学自在其中,嘴边也总是在背诵着植物的”光合作用”,”呼吸作用”,这些知识早已深深铭记在心中,刻印在脑海,挥之不去. 植物白天进行光合作用,吸收二氧化碳,释放氧气;夜晚呼吸作用吸收氧气,释放二氧化碳.这些知识让我认识了世界,然而并没有让我认识他.起初还是傻乎乎的每天出门上班时,把花放在窗台上,打开窗子,让他沐浴阳光,接受洗礼;可最近在浏览一些网站时,注意到一句话让我困惑不已—-“给予植物充足的光照,可以放在阳台上,但要避免太阳光直射”. 我懵了,我真的懵了, 既然都选择放在窗台上,难道窗台上的阳关就不是太阳直射了嘛????? 我很困惑, 爱琢磨的我在想, 窗台上有玻璃,Uh… 难道是隔着一层玻璃就不算直射了吗,, 哎, 这个问题,到现在我也没有想清楚.在经过不断的查询我发现其实植物进行光合作用并不是之可以有太阳光才可以. 植物进行光合作用,叶绿体是主要功臣,高等植物的光合色素主要有叶绿素和类胡萝卜素,在颜色上叶绿素(叶绿素a 和叶绿色 b) 主要呈绿色, 类胡萝卜素(胡萝卜素和叶黄素) 呈黄色.叶绿素吸收光的能力极强,而对植物光合作用起到作用的是波长在 640 ~ 670 nm 的红光部分和波长在 430 ~ 450 的蓝紫光部分;因为太阳光不是单一的光,到达地表后波长在 300nm ~ 2600 nm, 只有波长在 390 ~ 770 nm为可见光(也就是我们常说的红橙黄绿青蓝紫,及其混合色),自然太阳光是可以满足植物进行光合作用的,同时,我们日常的照明灯例如:白炽灯,荧光灯,LED 灯,他们也可满足植物进行光合作用,但他们的波长不能满足植物光合作用的所有波长选择, 只能是单一, 比如只满足红光或蓝紫光.使用照明灯进行光照,只会导致植物缺少一些元素;淘宝上也有专门买植物光合作用需要的红光和蓝光的灯,但怎样都不如植物在外面晒几小时,大自然就是这么神奇. 昨天为我的小心念移植了新居,因为刚刚收到他时,他的家有点破败,索性就为他换个豪宅.先用小铲铲松他的根基(不要贴着他,不然会伤害到哦),要不要用力去拔,伤到根部,就再也救不活了.慢慢的,要细心,待整体都很松动,能够连根带土的,一起从盆中带出,在新家先给他挖好容身之所,用手拖住他,细心的放在新家处,并埋好,然后少量的给予一些水分, 让他的家根基更夯实,不要过度浇水,但也要浇头,保持土壤松弛,这样氧气才能进入到土壤,让根部能够充分的进行呼吸作用.一直新家后,小心念属于脆弱的时候,这时不要让他在阳光下暴晒,不利于根部在新家落根. 新家已经安排妥当,之后就是用心去观察他的变化,保持通风,和光照,他才会茁壮成长.]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清香木养殖（一）]]></title>
    <url>%2F2019%2F05%2F04%2F%E6%B8%85%E9%A6%99%E6%9C%A8%E5%85%BB%E6%AE%96%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[激动的心，颤抖的手，京东上面动动手。哈哈，很久就有想养一个绿植的想法，经过了半年的挣扎，终于在 3 天前动起了手，入手一株清香木，据老板说，清香木可以散发出香味，充满整个房间，香气四溢（还未鉴定，刚收到，正怀着激动的心在写）。 其实对这枝有一点小失望，就是个头太小，不过没关系，咱俩熬呗，早晚你会长大的。 那么问题来了，我是一只程序狗，这种张飞绣花的事儿，着实让我头疼了一番；平日里坐在电脑前，噼里啪啦的敲着键盘，书写着一行行 ABC（突然想起一首歌《都选 C》），徜徉在编码的世界里。忽然之间，生活中多了一株绿植，让那份隐藏在我身体某处多年的小爱心又如雨后春笋一般，萌发了起来。可是啊，在编码的世界里，我可以装装样子，但在 ta 的世界里，我只能装孙子。 自此之后，我将踏上绿植的养护之道，千里之行始于足下，就请你把我带入到你的世界里，深入的了解并爱上你吧。 OK，说正事儿，先来介绍一下清香木： 清香木非常收到花友的喜爱，是一种非常理想的盆栽植物，盆景清香木摆放在室内，能营造出一种野外山水树木移入家内的感觉，自然清新。原本生长我国的云脑中部、北部及四川南部等高海拔的干热河谷地带，具有耐阴性，喜好暖，生长缓慢，寿命长等特点（这也会我选择样 ta 的原因）。 这里有一个养花的 APP，养花大全，我就是在这上学习养花的技术及注意事项的。 虽然我并没有经理过 ta 的出生，但后面的路我想和你一起。为你整理发型（修剪枝叶）、为你安家乐业（上盆定型），呵护你（土壤和水分），一路前行（光照和温度）。 虽然 APP 上介绍了清香木一些喜好，也提供了一些养殖方法，但身在门外汉的我还是对绿植界的术语感到头疼，下面来介绍一下 术语 含义 见干见湿 见干：土壤干涸，表面看不到潮湿。 见湿：浇水时，看土壤全部浸湿。 浇水要浇透 浇水时，见到水从底部孔流出 这个表格是我在看清香木养殖事项时遇到的问题，以后会继续更新。虽然这个术语刚到看的时候，一脸懵。我也请教了我的同事关于养护的问题，他也细心的解释了，而且还特别照顾我这个小白，用很生动的比喻让我理解透了这些属于。 那么这里我在详细的说一下我的理解： 见干见湿：要解释的和上面的含义一样，那么我还要补充的部分就是，土壤是自上而下干的， 因此表面上虽然干了，但是土壤内部其实还没有干，尤其是土壤底部（植物的根部），这个时候我们可以通过向土壤中插入一根木棍（要插到底儿哦😏），专门用来检测土壤湿度，拔出时记住木棍裸露在土壤外面的位置，拔出后用潮湿的部位去计算位置。保持根部的湿润，可以促进植物根系的发展，因此不需要经常给植物浇水。见湿也就是浇水时，保证土壤湿润即可。 浇水要浇透：当我看到时我也和纳闷什么意思，而且和上面的见湿似乎又冲突，到底是见到土壤湿了就可以，还是要浇透？那什么又是浇透呢？经过我的调研和咨询，终于弄明白，这些情况是和土壤的成分有关系，因为土壤的透气性、保水性都对植物发育有很大影响，一旦有问题，很可能导致叶子发黄，脱落，甚至死亡。Emmm 我们说浇透的事儿，花盆底部是有一个小口的（不养花根部不懂事干嘛的，小时候帮妈妈浇花，水从那漏出来，还以为浪费了呢）。因为土壤成分不同，吸水、蓄水能力也不同，具体土壤成分先不介绍，简单说下原理—可以先浇一遍快水，就是将水分均匀的洒在土壤的表面，不要留干，都浸湿，见盆地有水分流出即可，等到 10 分钟之后，在进行一次浇水，同样是均匀的浇，并底部有水流出即可。这样就可以保证浇透了。 小白在这献丑了，后续会持续更新]]></content>
      <tags>
        <tag>绿植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp Intercept]]></title>
    <url>%2F2019%2F04%2F30%2FOkHttp-Intercept%2F</url>
    <content type="text"><![CDATA[OkHttp InterceptorOKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子 要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法. 这里介绍两种 Interceptor 的实例 Log 日志 (LogInterceptor)Log 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等. 这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等. 话不多说, 上代码. 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 自定义 log 拦截器,输入请求地址,请求参,请求结果*/public class LogInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 拦截请求信息,获取请求地址及请求参数 Request request = chain.request(); long t1 = System.nanoTime(); // 获取请求方式 String method = request.method(); if ("POST".equals(method)) &#123; StringBuilder sb = new StringBuilder(); if (request.body() instanceof FormBody) &#123; FormBody body = (FormBody) request.body(); for (int i = 0; i &lt; body.size(); i++) &#123; sb.append(body.encodedName(i) + "=" + body.encodedValue(i) + ","); &#125; sb.delete(sb.length() - 1, sb.length()); LogUtils.d(TAG, String.format("Sending request %s on %s %n%s %nRequestParams:&#123;%s&#125;", request.url(), chain.connection(), request.headers(), sb.toString())); &#125; &#125; else &#123; LogUtils.d(TAG, String.format("Sending request %s on %s %n%s", request.url(), chain.connection(), request.headers())); &#125; // 获取响应信息 Response response = chain.proceed(request); long t2 = System.nanoTime(); LogUtils.d(TAG, String.format("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers())); MediaType contentType = response.body().contentType(); String content = response.body().string(); LogUtils.d(TAG, content); ResponseBody wrappedBody = ResponseBody.create(contentType, content); return response.newBuilder().body(wrappedBody).build(); &#125; &#125; 加参加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为公参, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便. 因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数. 公参拦截器在请求中,增加一些公共的参数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class CommonParamsInterceptor implements Interceptor &#123; private Map&lt;String, String&gt; queryParamsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; headerParamsMap = new HashMap&lt;&gt;(); private List&lt;String&gt; headerLinesList = new ArrayList&lt;&gt;(); @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); // process header params inject Headers.Builder headerBuilder = request.headers().newBuilder(); if (headerParamsMap.size() &gt; 0) &#123; Iterator iterator = headerParamsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); headerBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; if (headerLinesList.size() &gt; 0) &#123; for (String line : headerLinesList) &#123; headerBuilder.add(line); &#125; requestBuilder.headers(headerBuilder.build()); &#125; // process header params end // process queryParams inject whatever it's GET or POST if (queryParamsMap.size() &gt; 0 &amp;&amp; "GET".equals(request.method())) &#123;// if (queryParamsMap.size() &gt; 0) &#123; request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap); &#125; // process post body inject if (paramsMap != null &amp;&amp; paramsMap.size() &gt; 0 &amp;&amp; "POST".equals(request.method())) &#123; if (request.body() instanceof FormBody) &#123; FormBody.Builder newFormBodyBuilder = new FormBody.Builder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; FormBody oldFormBody = (FormBody) request.body(); int paramSize = oldFormBody.size(); if (paramSize &gt; 0) &#123; for (int i = 0; i &lt; paramSize; i++) &#123; newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i)); &#125; &#125; requestBuilder.post(newFormBodyBuilder.build()); request = requestBuilder.build(); &#125; else if (request.body() instanceof MultipartBody) &#123; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue()); &#125; List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; requestBuilder.post(multipartBuilder.build()); request = requestBuilder.build(); &#125; &#125; return chain.proceed(request); &#125; private boolean canInjectIntoBody(Request request) &#123; if (request == null) &#123; return false; &#125; if (!TextUtils.equals(request.method(), "POST")) &#123; return false; &#125; RequestBody body = request.body(); if (body == null) &#123; return false; &#125; MediaType mediaType = body.contentType(); if (mediaType == null) &#123; return false; &#125; if (!TextUtils.equals(mediaType.subtype(), "x-www-form-urlencoded")) &#123; return false; &#125; return true; &#125; // func to inject params into url private Request injectParamsIntoUrl(Request request, Request.Builder requestBuilder, Map&lt;String, String&gt; paramsMap) &#123; HttpUrl.Builder httpUrlBuilder = request.url().newBuilder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue()); &#125; requestBuilder.url(httpUrlBuilder.build()); return requestBuilder.build(); &#125; return request; &#125; private static String bodyToString(final RequestBody request) &#123; try &#123; final RequestBody copy = request; final Buffer buffer = new Buffer(); if (copy != null) copy.writeTo(buffer); else return ""; return buffer.readUtf8(); &#125; catch (final IOException e) &#123; return "did not work"; &#125; &#125; public static class Builder &#123; CommonParamsInterceptor interceptor; public Builder() &#123; interceptor = new CommonParamsInterceptor(); &#125; public Builder addParam(String key, String value) &#123; interceptor.paramsMap.put(key, value); return this; &#125; public Builder addParamsMap(Map&lt;String, String&gt; paramsMap) &#123; interceptor.paramsMap.putAll(paramsMap); return this; &#125; public Builder addHeaderParam(String key, String value) &#123; interceptor.headerParamsMap.put(key, value); return this; &#125; public Builder addHeaderParamsMap(Map&lt;String, String&gt; headerParamsMap) &#123; interceptor.headerParamsMap.putAll(headerParamsMap); return this; &#125; public Builder addHeaderLine(String headerLine) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); return this; &#125; public Builder addHeaderLinesList(List&lt;String&gt; headerLinesList) &#123; for (String headerLine : headerLinesList) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); &#125; return this; &#125; public Builder addQueryParam(String key, String value) &#123; interceptor.queryParamsMap.put(key, value); return this; &#125; public Builder addQueryParamsMap(Map&lt;String, String&gt; queryParamsMap) &#123; interceptor.queryParamsMap.putAll(queryParamsMap); return this; &#125; public CommonParamsInterceptor build() &#123; return interceptor; &#125; &#125;&#125; 加签拦截器互联网是一个开放的环境,危险无处不在,加密通信是安全的基础. 加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签; 加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥. 这里介绍一种加签方式, 加密规则 根据请求参数 key 进行排序 按排好的顺序组装成 key=value&amp;key=value 形式的字符串 将上述字符串拼接 ,最终形成 key=value&amp;key=value的字符串 将字符串 md5, 生成 auth. 一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243public class AuthorizeInterceptor implements Interceptor &#123; private static final String TAG = "AuthorizeInterceptor"; /** * 生成 auth 的私钥 */ private String authKey; /** * 当前设备 mid,用来生成 auth * 数据由 Builder 类传入 */ private String mid = ""; private AuthorizeInterceptor() &#123; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); String url = request.url().toString(); LogUtils.d(TAG, url); if ("POST".equals(request.method())) &#123; request = injectionParamIntoBody(request, requestBuilder); &#125; else if ("GET".equals(request.method())) &#123; request = injectionAuthIntoUrl(request, requestBuilder); &#125; return chain.proceed(request); &#125; /** * GET 请求方式, 生成授权和添加时间戳 * * @param request * @param requestBuilder * @return */ private Request injectionAuthIntoUrl(Request request, Request.Builder requestBuilder) &#123; //获取到请求地址api HttpUrl newHttpUrl = request.url(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); //通过请求地址(最初始的请求地址)获取到参数列表 Set&lt;String&gt; parameterNames = newHttpUrl.queryParameterNames(); for (String key : parameterNames) &#123; //循环参数列表,获取参数value, String paramValue = newHttpUrl.queryParameter(key); if (!TextUtils.isEmpty(paramValue)) &#123; authMap.put(key, paramValue); &#125; &#125; HttpUrl.Builder newBuilder = request.url().newBuilder() .addEncodedQueryParameter("auth", assembleAuth(authMap, false)); requestBuilder.url(newBuilder.build()); return requestBuilder.build(); &#125; /** * 将参数注入到 POST 请求的 body 中 * * @param request * @param requestBuilder * @return */ private Request injectionParamIntoBody(Request request, Request.Builder requestBuilder) &#123; if (request.body() instanceof FormBody) &#123; // 处理正常表单请求方式 FormBody oldFormBody = (FormBody) request.body(); return assembleFormBody(request, oldFormBody, requestBuilder); &#125; else if (request.body() instanceof MultipartBody) &#123; return assembleMultipartBody(request, requestBuilder); &#125; else &#123; return request; &#125; &#125; /** * 构建流媒体参数的 body * * @param request * @param builder * @return */ private Request assembleMultipartBody(Request request, Request.Builder builder) &#123; // 处理流的请求方式 MultipartBody body = (MultipartBody) request.body(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序 if (body != null &amp;&amp; body.parts().size() &gt; 0) &#123; for (MultipartBody.Part part : body.parts()) &#123; // 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理 if (part.body().contentType() == null || !"image".equals(part.body().contentType().type()) || "text".equals(part.body().contentType().type())) &#123; Headers headers = part.headers(); // 从 header 中获取 Key, form-data; name= 的字段过滤获取key // 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value // 将 key 和 value 填充到 TreeMap 中 for (int i = 0; i &lt; headers.names().size(); i++) &#123; String headerName = headers.value(i); if (headerName.contains("form-data; name=")) &#123; String key = headerName.replace("form-data; name=", "").replace("\"", ""); String value = body2String(part.body()); if (!TextUtils.isEmpty(value)) &#123; authMap.put(key, body2String(part.body())); &#125; &#125; &#125; &#125; &#125; &#125; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); multipartBuilder.addFormDataPart("auth", assembleAuth(authMap, false)); List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; builder.post(multipartBuilder.build()); return builder.build(); &#125; /** * 构建 Auth 数据 * &lt;p&gt; * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&amp;key=value 的形式, * Map 拼接完成后,在其后需要再次拼接上 * &lt;p&gt; * 最后将数据 MD5 转化为 32 位小写并返回 * * @param treeMap 构建 Auth 的具体数据 * @param isNeedDecode 是否需要解码 * @return 返回 auth 数据 */ private String assembleAuth(TreeMap&lt;String, String&gt; treeMap, boolean isNeedDecode) &#123; StringBuilder stringBuilder = new StringBuilder(); if (treeMap.size() &gt; 0) &#123; for (Map.Entry&lt;String, String&gt; stringStringEntry : treeMap.entrySet()) &#123; try &#123; stringBuilder.append(stringStringEntry.getKey()) .append("=") .append(isNeedDecode ? URLDecoder.decode(stringStringEntry.getValue(), "UTF-8") : stringStringEntry.getValue()) .append("&amp;"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; treeMap.clear(); stringBuilder .append(authKey); Log.d(TAG, stringBuilder.toString()); return MD5.MD5(stringBuilder.toString()); &#125; /** * body 转 string 获取实际参数值 * * @param body Part body * @return part 中写如的参数数据 */ private String body2String(RequestBody body) &#123; if (body != null) &#123; Buffer buffer = new Buffer(); try &#123; body.writeTo(buffer); Charset charset = Charset.forName("UTF-8"); MediaType contentType = body.contentType(); if (contentType != null) &#123; charset = contentType.charset(charset); &#125; assert charset != null; return buffer.readString(charset); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return ""; &#125; /** * 组装 Form 表单请求数据 * * @param request * @param oldFormBody * @param requestBuilder * @return */ private Request assembleFormBody(Request request, FormBody oldFormBody, Request.Builder requestBuilder) &#123; TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 遍历请求参数,非空参数,添加到集合中 for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; if (!TextUtils.isEmpty(oldFormBody.encodedValue(i))) &#123; authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; &#125; if (authMap.size() != 0) &#123; // 生成 auth 数据 FormBody.Builder newFormBody = new FormBody.Builder(); for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; newFormBody.add("auth", assembleAuth(authMap, true)); requestBuilder.method(request.method(), newFormBody.build()); return requestBuilder.build(); &#125; return request; &#125; /** * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作 */ public static class Builder &#123; AuthorizeInterceptor authorizeInterceptor; public Builder() &#123; authorizeInterceptor = new AuthorizeInterceptor(); &#125; public Builder setMid(String mid) &#123; authorizeInterceptor.mid = mid; return this; &#125; public Builder setAuthKey(String key) &#123; authorizeInterceptor.authKey = key; return this; &#125; public AuthorizeInterceptor build() &#123; return authorizeInterceptor; &#125; &#125;&#125; 该加签方式,讲请求参数拼接为 key=value 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 contentType 而又有所不同,这里介绍了Form表单提交和 Multipart 上传文件的参数获取方式,其他的请举一反三.]]></content>
    <content type="text"><![CDATA[OKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子 要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法. 这里介绍两种 Interceptor 的实例 Log 日志 (LogInterceptor)Log 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等. 这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等. 话不多说, 上代码. 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 自定义 log 拦截器,输入请求地址,请求参,请求结果*/public class LogInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 拦截请求信息,获取请求地址及请求参数 Request request = chain.request(); long t1 = System.nanoTime(); // 获取请求方式 String method = request.method(); if ("POST".equals(method)) &#123; StringBuilder sb = new StringBuilder(); if (request.body() instanceof FormBody) &#123; FormBody body = (FormBody) request.body(); for (int i = 0; i &lt; body.size(); i++) &#123; sb.append(body.encodedName(i) + "=" + body.encodedValue(i) + ","); &#125; sb.delete(sb.length() - 1, sb.length()); LogUtils.d(TAG, String.format("Sending request %s on %s %n%s %nRequestParams:&#123;%s&#125;", request.url(), chain.connection(), request.headers(), sb.toString())); &#125; &#125; else &#123; LogUtils.d(TAG, String.format("Sending request %s on %s %n%s", request.url(), chain.connection(), request.headers())); &#125; // 获取响应信息 Response response = chain.proceed(request); long t2 = System.nanoTime(); LogUtils.d(TAG, String.format("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers())); MediaType contentType = response.body().contentType(); String content = response.body().string(); LogUtils.d(TAG, content); ResponseBody wrappedBody = ResponseBody.create(contentType, content); return response.newBuilder().body(wrappedBody).build(); &#125; &#125; 加参加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为公参, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便. 因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数. 公参拦截器在请求中,增加一些公共的参数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class CommonParamsInterceptor implements Interceptor &#123; private Map&lt;String, String&gt; queryParamsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; headerParamsMap = new HashMap&lt;&gt;(); private List&lt;String&gt; headerLinesList = new ArrayList&lt;&gt;(); @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); // process header params inject Headers.Builder headerBuilder = request.headers().newBuilder(); if (headerParamsMap.size() &gt; 0) &#123; Iterator iterator = headerParamsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); headerBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; if (headerLinesList.size() &gt; 0) &#123; for (String line : headerLinesList) &#123; headerBuilder.add(line); &#125; requestBuilder.headers(headerBuilder.build()); &#125; // process header params end // process queryParams inject whatever it's GET or POST if (queryParamsMap.size() &gt; 0 &amp;&amp; "GET".equals(request.method())) &#123;// if (queryParamsMap.size() &gt; 0) &#123; request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap); &#125; // process post body inject if (paramsMap != null &amp;&amp; paramsMap.size() &gt; 0 &amp;&amp; "POST".equals(request.method())) &#123; if (request.body() instanceof FormBody) &#123; FormBody.Builder newFormBodyBuilder = new FormBody.Builder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; FormBody oldFormBody = (FormBody) request.body(); int paramSize = oldFormBody.size(); if (paramSize &gt; 0) &#123; for (int i = 0; i &lt; paramSize; i++) &#123; newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i)); &#125; &#125; requestBuilder.post(newFormBodyBuilder.build()); request = requestBuilder.build(); &#125; else if (request.body() instanceof MultipartBody) &#123; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue()); &#125; List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; requestBuilder.post(multipartBuilder.build()); request = requestBuilder.build(); &#125; &#125; return chain.proceed(request); &#125; private boolean canInjectIntoBody(Request request) &#123; if (request == null) &#123; return false; &#125; if (!TextUtils.equals(request.method(), "POST")) &#123; return false; &#125; RequestBody body = request.body(); if (body == null) &#123; return false; &#125; MediaType mediaType = body.contentType(); if (mediaType == null) &#123; return false; &#125; if (!TextUtils.equals(mediaType.subtype(), "x-www-form-urlencoded")) &#123; return false; &#125; return true; &#125; // func to inject params into url private Request injectParamsIntoUrl(Request request, Request.Builder requestBuilder, Map&lt;String, String&gt; paramsMap) &#123; HttpUrl.Builder httpUrlBuilder = request.url().newBuilder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue()); &#125; requestBuilder.url(httpUrlBuilder.build()); return requestBuilder.build(); &#125; return request; &#125; private static String bodyToString(final RequestBody request) &#123; try &#123; final RequestBody copy = request; final Buffer buffer = new Buffer(); if (copy != null) copy.writeTo(buffer); else return ""; return buffer.readUtf8(); &#125; catch (final IOException e) &#123; return "did not work"; &#125; &#125; public static class Builder &#123; CommonParamsInterceptor interceptor; public Builder() &#123; interceptor = new CommonParamsInterceptor(); &#125; public Builder addParam(String key, String value) &#123; interceptor.paramsMap.put(key, value); return this; &#125; public Builder addParamsMap(Map&lt;String, String&gt; paramsMap) &#123; interceptor.paramsMap.putAll(paramsMap); return this; &#125; public Builder addHeaderParam(String key, String value) &#123; interceptor.headerParamsMap.put(key, value); return this; &#125; public Builder addHeaderParamsMap(Map&lt;String, String&gt; headerParamsMap) &#123; interceptor.headerParamsMap.putAll(headerParamsMap); return this; &#125; public Builder addHeaderLine(String headerLine) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); return this; &#125; public Builder addHeaderLinesList(List&lt;String&gt; headerLinesList) &#123; for (String headerLine : headerLinesList) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); &#125; return this; &#125; public Builder addQueryParam(String key, String value) &#123; interceptor.queryParamsMap.put(key, value); return this; &#125; public Builder addQueryParamsMap(Map&lt;String, String&gt; queryParamsMap) &#123; interceptor.queryParamsMap.putAll(queryParamsMap); return this; &#125; public CommonParamsInterceptor build() &#123; return interceptor; &#125; &#125;&#125; 加签拦截器互联网是一个开放的环境,危险无处不在,加密通信是安全的基础. 加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签; 加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥. 这里介绍一种加签方式, 加密规则 根据请求参数 key 进行排序 按排好的顺序组装成 key=value&amp;key=value 形式的字符串 将上述字符串拼接 ,最终形成 key=value&amp;key=value的字符串 将字符串 md5, 生成 auth. 一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243public class AuthorizeInterceptor implements Interceptor &#123; private static final String TAG = "AuthorizeInterceptor"; /** * 生成 auth 的私钥 */ private String authKey; /** * 当前设备 mid,用来生成 auth * 数据由 Builder 类传入 */ private String mid = ""; private AuthorizeInterceptor() &#123; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); String url = request.url().toString(); LogUtils.d(TAG, url); if ("POST".equals(request.method())) &#123; request = injectionParamIntoBody(request, requestBuilder); &#125; else if ("GET".equals(request.method())) &#123; request = injectionAuthIntoUrl(request, requestBuilder); &#125; return chain.proceed(request); &#125; /** * GET 请求方式, 生成授权和添加时间戳 * * @param request * @param requestBuilder * @return */ private Request injectionAuthIntoUrl(Request request, Request.Builder requestBuilder) &#123; //获取到请求地址api HttpUrl newHttpUrl = request.url(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); //通过请求地址(最初始的请求地址)获取到参数列表 Set&lt;String&gt; parameterNames = newHttpUrl.queryParameterNames(); for (String key : parameterNames) &#123; //循环参数列表,获取参数value, String paramValue = newHttpUrl.queryParameter(key); if (!TextUtils.isEmpty(paramValue)) &#123; authMap.put(key, paramValue); &#125; &#125; HttpUrl.Builder newBuilder = request.url().newBuilder() .addEncodedQueryParameter("auth", assembleAuth(authMap, false)); requestBuilder.url(newBuilder.build()); return requestBuilder.build(); &#125; /** * 将参数注入到 POST 请求的 body 中 * * @param request * @param requestBuilder * @return */ private Request injectionParamIntoBody(Request request, Request.Builder requestBuilder) &#123; if (request.body() instanceof FormBody) &#123; // 处理正常表单请求方式 FormBody oldFormBody = (FormBody) request.body(); return assembleFormBody(request, oldFormBody, requestBuilder); &#125; else if (request.body() instanceof MultipartBody) &#123; return assembleMultipartBody(request, requestBuilder); &#125; else &#123; return request; &#125; &#125; /** * 构建流媒体参数的 body * * @param request * @param builder * @return */ private Request assembleMultipartBody(Request request, Request.Builder builder) &#123; // 处理流的请求方式 MultipartBody body = (MultipartBody) request.body(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序 if (body != null &amp;&amp; body.parts().size() &gt; 0) &#123; for (MultipartBody.Part part : body.parts()) &#123; // 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理 if (part.body().contentType() == null || !"image".equals(part.body().contentType().type()) || "text".equals(part.body().contentType().type())) &#123; Headers headers = part.headers(); // 从 header 中获取 Key, form-data; name= 的字段过滤获取key // 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value // 将 key 和 value 填充到 TreeMap 中 for (int i = 0; i &lt; headers.names().size(); i++) &#123; String headerName = headers.value(i); if (headerName.contains("form-data; name=")) &#123; String key = headerName.replace("form-data; name=", "").replace("\"", ""); String value = body2String(part.body()); if (!TextUtils.isEmpty(value)) &#123; authMap.put(key, body2String(part.body())); &#125; &#125; &#125; &#125; &#125; &#125; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); multipartBuilder.addFormDataPart("auth", assembleAuth(authMap, false)); List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; builder.post(multipartBuilder.build()); return builder.build(); &#125; /** * 构建 Auth 数据 * &lt;p&gt; * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&amp;key=value 的形式, * Map 拼接完成后,在其后需要再次拼接上 * &lt;p&gt; * 最后将数据 MD5 转化为 32 位小写并返回 * * @param treeMap 构建 Auth 的具体数据 * @param isNeedDecode 是否需要解码 * @return 返回 auth 数据 */ private String assembleAuth(TreeMap&lt;String, String&gt; treeMap, boolean isNeedDecode) &#123; StringBuilder stringBuilder = new StringBuilder(); if (treeMap.size() &gt; 0) &#123; for (Map.Entry&lt;String, String&gt; stringStringEntry : treeMap.entrySet()) &#123; try &#123; stringBuilder.append(stringStringEntry.getKey()) .append("=") .append(isNeedDecode ? URLDecoder.decode(stringStringEntry.getValue(), "UTF-8") : stringStringEntry.getValue()) .append("&amp;"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; treeMap.clear(); stringBuilder .append(authKey); Log.d(TAG, stringBuilder.toString()); return MD5.MD5(stringBuilder.toString()); &#125; /** * body 转 string 获取实际参数值 * * @param body Part body * @return part 中写如的参数数据 */ private String body2String(RequestBody body) &#123; if (body != null) &#123; Buffer buffer = new Buffer(); try &#123; body.writeTo(buffer); Charset charset = Charset.forName("UTF-8"); MediaType contentType = body.contentType(); if (contentType != null) &#123; charset = contentType.charset(charset); &#125; assert charset != null; return buffer.readString(charset); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return ""; &#125; /** * 组装 Form 表单请求数据 * * @param request * @param oldFormBody * @param requestBuilder * @return */ private Request assembleFormBody(Request request, FormBody oldFormBody, Request.Builder requestBuilder) &#123; TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 遍历请求参数,非空参数,添加到集合中 for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; if (!TextUtils.isEmpty(oldFormBody.encodedValue(i))) &#123; authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; &#125; if (authMap.size() != 0) &#123; // 生成 auth 数据 FormBody.Builder newFormBody = new FormBody.Builder(); for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; newFormBody.add("auth", assembleAuth(authMap, true)); requestBuilder.method(request.method(), newFormBody.build()); return requestBuilder.build(); &#125; return request; &#125; /** * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作 */ public static class Builder &#123; AuthorizeInterceptor authorizeInterceptor; public Builder() &#123; authorizeInterceptor = new AuthorizeInterceptor(); &#125; public Builder setMid(String mid) &#123; authorizeInterceptor.mid = mid; return this; &#125; public Builder setAuthKey(String key) &#123; authorizeInterceptor.authKey = key; return this; &#125; public AuthorizeInterceptor build() &#123; return authorizeInterceptor; &#125; &#125;&#125; 该加签方式,讲请求参数拼接为 key=value 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 contentType 而又有所不同,这里介绍了Form表单提交和 Multipart 上传文件的参数获取方式,其他的请举一反三.]]></content>
>>>>>>> c1e1d1e28407f3ab1f40fc8a12b186e1bb22e897
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个 ssh 公钥提交代码到不同平台]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%2F</url>
<<<<<<< HEAD
    <content type="text"><![CDATA[[TOC] 多个 SSH 公钥提交代码到不同平台作为一个技术开发人员，免不了在 github 以及 gitlab 以及其他 git 平台上进行代码管理；工作中您可能使用 svn （这不在我们的讨论范围）,也有可能使用 git, 生活中，您可能会将一些内容分享到你的 github 上， 供大家参阅。 git 创建版本库很容易， clone 代码也仅仅是简单的一句 git clone https://github.com/xxxx.git，异或是 git clone git@github.com:xxxxx.git；当然，使用 https 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 https 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 SSH 的方式来处理 git 的版本管理。 生成 SSH 密钥使用 SSH 创建一套公密钥，将公钥添加到你要使用的 Git 平台账户下 1ssh-keygen -t rsa -C &quot;your email addr&quot; -f ~/.ssh/github 注意： -f 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略 命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理） 添加生成的 SSH 公钥添加 ssh 公钥到 github ** 打开 https://github.com/settings/profile ，选择 SSH and GPG keys 点击 New SSH key title 可以随便写，建议见名知意，能知道是哪台设备 key 通过刚刚通过 SSH 命令生成的 .pub 文件中复制即可。文件路径 .ssh/id_rsa.pub 异或是存在您 -f 之后指定的目录。 点击 add SSH key 配置多个 ssh配置多个 ssh 时，需要注意的是： 如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 ssh 公钥到对应平台，否则，后续的 ssh 创建过程， 会覆盖掉之前创建的。 ssh-keygen 会同时创建 id_rsa 和 id_rsa.pub 两个文件， .pub 是公钥， 不带后缀的是你的私钥。 同时配置多个 ssh 时，需要您保留私钥在 .ssh 目录下，为保证多平台都可以使用，您需要手动修改一下 id_rsa 文件的名称，.pub 就随便了，配置完，就没用了。 将密钥添加到 ssh-agent 中 1ssh-add ~.ssh/id_rsa 123456# 查看 agent 中的密钥ssh-add -l# 查看 agent 中的公钥ssh-add -L# 删除 agent 中的密钥ssh-add -d .ssh/id_xxx.pub 修改配置文件说了半天，终于到重点了 在 ~/.ssh 目录下新建一个 config 文件 对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 ssh 密钥。 touch config 添加以下配置信息 12345678910111213# githubHost github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓HostName github.com # 同上PreferredAuthentications publickey # 这里不要修改IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥# gitlabHost 公司 gitlab 地址HostName 公司 gitlab 地址PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_gitlab... 测试命令为： 1ssh -T git@github.com 结果 1Hi boywithsmalleyes! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 只需要替换后面的 git仓库地址, 其他版本库都可以进行测试。 结语说了半天， 还是要记住一点，既然要使用 ssh 的方式进行版本管理，那么在 clone 代码时，也要使用 ssh 方式， 不然我说了这么半天，都是白扯。 文章内容有瑕疵，请给予指正批评]]></content>
    <content type="text"><![CDATA[作为一个技术开发人员，免不了在 github 以及 gitlab 以及其他 git 平台上进行代码管理；工作中您可能使用 svn （这不在我们的讨论范围）,也有可能使用 git, 生活中，您可能会将一些内容分享到你的 github 上， 供大家参阅。 git 创建版本库很容易， clone 代码也仅仅是简单的一句 git clone https://github.com/xxxx.git，异或是 git clone git@github.com:xxxxx.git；当然，使用 https 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 https 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 SSH 的方式来处理 git 的版本管理。 生成 SSH 密钥使用 SSH 创建一套公密钥，将公钥添加到你要使用的 Git 平台账户下 1ssh-keygen -t rsa -C &quot;your email addr&quot; -f ~/.ssh/github 注意： -f 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略 命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理） 添加生成的 SSH 公钥添加 ssh 公钥到 github ** 打开 https://github.com/settings/profile ，选择 SSH and GPG keys 点击 New SSH key title 可以随便写，建议见名知意，能知道是哪台设备 key 通过刚刚通过 SSH 命令生成的 .pub 文件中复制即可。文件路径 .ssh/id_rsa.pub 异或是存在您 -f 之后指定的目录。 点击 add SSH key 配置多个 ssh配置多个 ssh 时，需要注意的是： 如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 ssh 公钥到对应平台，否则，后续的 ssh 创建过程， 会覆盖掉之前创建的。 ssh-keygen 会同时创建 id_rsa 和 id_rsa.pub 两个文件， .pub 是公钥， 不带后缀的是你的私钥。 同时配置多个 ssh 时，需要您保留私钥在 .ssh 目录下，为保证多平台都可以使用，您需要手动修改一下 id_rsa 文件的名称，.pub 就随便了，配置完，就没用了。 将密钥添加到 ssh-agent 中 1ssh-add ~.ssh/id_rsa 123456# 查看 agent 中的密钥ssh-add -l# 查看 agent 中的公钥ssh-add -L# 删除 agent 中的密钥ssh-add -d .ssh/id_xxx.pub 修改配置文件说了半天，终于到重点了 在 ~/.ssh 目录下新建一个 config 文件 对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 ssh 密钥。 touch config 添加以下配置信息 12345678910111213# githubHost github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓HostName github.com # 同上PreferredAuthentications publickey # 这里不要修改IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥# gitlabHost 公司 gitlab 地址HostName 公司 gitlab 地址PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_gitlab... 测试命令为： 1ssh -T git@github.com 结果 1Hi boywithsmalleyes! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 只需要替换后面的 git仓库地址, 其他版本库都可以进行测试。 结语说了半天， 还是要记住一点，既然要使用 ssh 的方式进行版本管理，那么在 clone 代码时，也要使用 ssh 方式， 不然我说了这么半天，都是白扯。 文章内容有瑕疵，请给予指正批评]]></content>
>>>>>>> c1e1d1e28407f3ab1f40fc8a12b186e1bb22e897
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 判断字符串是否是数字的方法]]></title>
    <url>%2F2019%2F04%2F16%2FJava-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用 Java自带的函数 12345678public static boolean isNumeric (String str) &#123; for (int i = str.length(); --i &gt;=0) &#123; if (!Character.isDigit(str.charAt(i))) &#123; return false; &#125; &#125; return true;&#125; 使用正则表达式 方法一: 1234public static boolean isNumeric(String str) &#123; Pattern pattern = Pattern.compile(&quot;^[-\\+]?[\\d]*$&quot;); return pattern.matcher(str).matches();&#125; 方法二: 123456public static boolean isNumeric(String str) &#123; if (str != null &amp;&amp; !&quot;&quot;.equals(str.trim())) &#123; return s.matches(&quot;^[0-9]*$&quot;); &#125; return false;&#125; 方法三: 1234 public static boolean isNumeric (String str) &#123; Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;); return pattern.matcher(str).matcher();&#125; 使用 ASCII 码 123456789public static boolean isNumeric (String str) &#123; for (int i = str.length(); --i&gt;=0;) &#123; int chr = str.charAt(i); if (chr &lt; 48 || chr &gt; 57) &#123; return false; &#125; &#125; return true;&#125; 判断是不是浮点型数据 1234public static boolean isDouble(String str) &#123; Pattern pattern = Pattern.compile(&quot;^[-\\+]?[.\\d]*$&quot;); return pattern.matcher(str).matches();&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中设置全屏的方法]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置 一. 在代码中设置1234567891011public class BaseActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(saveInstanceState); // 无title requestWindowFeature(Window.FEATURE_NO_TITLE); // 全屏 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.activity_main); &#125; &#125; 强调一点: 设置全屏的两段代码,必须在 setContentView() 之前调用,不然会报错 二. 在配置文件中修改1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.test&quot; android:versionCode=&quot;1&quot; ndroid:versionName=&quot;1.0&quot;&gt; &lt;application android:icon=&quot;@drawable/icon&quot; android:lable=&quot;@string/app_name&gt; &lt;activity android:name=&quot;.BaseActivity&quot; android:theme=&quot;@android:style/Theme.NotitleBar.Fullscreen&quot; android:lable=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/application&gt;&lt;/manifest&gt; 使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 获取 IP 地址]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E8%8E%B7%E5%8F%96-IP-%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[开发中经常会需要判断当前是否连接网络, WiFi 或 移动数据连接判断的需求, 第一种方法: 123WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); 通过这种方式获取到的 IP 地址为一串数字,我们并不能看懂,因此我们需要通过下面的方法进行转换: 1String ip = (ipAddress &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;8 &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;16 &amp; 0xff) + &quot;.&quot; + (ipAddress &gt;&gt; 24 &amp; 0xff); 这样转换之后,我们获取到的 IP 地址就是我们平时认识的, 比如: 192.168.1.108 这种方法在飞行模式下获取到的 IP 地址为 0.0.0.0 第二种方法: 12345678910111213141516 public String getLocalIpAddress() &#123; try &#123; for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) &#123; return inetAddress.getHostAddress().toString(); &#125; &#125; &#125; &#125; catch (SocketException ex) &#123; Log.e(LOG_TAG, ex.toString()); &#125; return null; &#125; 第二种方式是比较通用的,在WiFi和3G/4G 状态下,都可以获取到正确的地址.比如: fe80::8e3a:e3ff:fe45:a018 这种方法在手机处于飞行状态下时, 获取到的 IP 地址为 null]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发]]></title>
    <url>%2F2019%2F04%2F16%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
<<<<<<< HEAD
    <content type="text"><![CDATA[事件分发事件分发的三个方法 dispatchTouchEvent(MotionEvent event) 判断当前 View 是否要消费此事件，消费，则不再向下传递，反之传递，以此来分发事件； onInterceptTouchEvent(MotionEvent event) 通过 dispatchTouchEvent 调用， 返回值用来判断当前 View 是否要消费事件； onTouchEvent(MotionEvent event) 当 View 决定消费事件，则将进行该方法的调用，依据具体的事件，及具体业务，实现不同的事件。 关于事件分发的一些结论： 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件系列以 down 事件开始， 中间含有若干个 move 事件， 最终以 up 事件结束； 正常情况下，一个事件序列只能被一个 View 拦截且消耗。这一套哦的原因可以参考 3， 因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个 View 同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件，通过 onTouchEvent强行传递给其他 View 处理； 某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果能传递到他的话），并且它的 onInterceptTouchEvent 不会再被调用。 某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent 返回 false）， 那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将会重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用，意思就是事件一旦交由一个 View 处理，那么它就必须消耗掉，否则同一事件序列中的剩下的事件就不在交给他来处理了。 如果 View 不消耗除 ACTION_DOWN 以外的其他事件， 那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续受到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。 ViewGroup 默认不拦截任何事件，Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。 View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给他，那么他的 onTouchEvent 方法就会被调用。 View 的 onTouchEvent 方法默认会消耗掉事件（返回 true），除非他是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都是 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认是 true，而 TextView 的 clickable 默认未 false。 View 的 enable 属性不影响 onTouchEvent 的默认返回值，哪怕一个 View 是 disable 状态，只要他的 clickable 或者 longClickable 有一个为 true， 那么他的 onTouchEvent 就返回true。 onClick 会发生的前提是 View 是可点击的，并且它收到了 down 和 up 事件。 事件传递过程是有外向内的，即事件总是先传递给父元素，然后在由父元素分发给子 View，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外（解决滑动冲突，内部拦截法）。 事件的传递过程：Activity -&gt; Window(PhoneWindow) -&gt; View -&gt; dispatchTouchEvent -&gt; onInterceptTouchEvent -&gt; onTouchEvent。 当一个 View 需要处理事件时，如果它设置了 onTouchListener，那么 onTouchListener 中的 onTouch 方法会被回调。这时事件如何处理要看 onTouch 的返回值，返回 false，则当前 View 的 onTouchEvent 被调用，true， 则不调用。View 的 onTouchListener 方法优先级高于 onTouchEvent；onClickListener（需要完成有 up 操作） 方法在 onTouchEvent 中被调用，因此，onClickListener 处于事件传递的尾端。]]></content>
    <content type="text"><![CDATA[事件分发的三个方法 dispatchTouchEvent(MotionEvent event) 判断当前 View 是否要消费此事件，消费，则不再向下传递，反之传递，以此来分发事件； onInterceptTouchEvent(MotionEvent event) 通过 dispatchTouchEvent 调用， 返回值用来判断当前 View 是否要消费事件； onTouchEvent(MotionEvent event) 当 View 决定消费事件，则将进行该方法的调用，依据具体的事件，及具体业务，实现不同的事件。 关于事件分发的一些结论： 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件系列以 down 事件开始， 中间含有若干个 move 事件， 最终以 up 事件结束； 正常情况下，一个事件序列只能被一个 View 拦截且消耗。这一套哦的原因可以参考 3， 因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个 View 同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件，通过 onTouchEvent强行传递给其他 View 处理； 某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果能传递到他的话），并且它的 onInterceptTouchEvent 不会再被调用。 某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent 返回 false）， 那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将会重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用，意思就是事件一旦交由一个 View 处理，那么它就必须消耗掉，否则同一事件序列中的剩下的事件就不在交给他来处理了。 如果 View 不消耗除 ACTION_DOWN 以外的其他事件， 那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续受到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。 ViewGroup 默认不拦截任何事件，Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。 View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给他，那么他的 onTouchEvent 方法就会被调用。 View 的 onTouchEvent 方法默认会消耗掉事件（返回 true），除非他是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都是 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认是 true，而 TextView 的 clickable 默认未 false。 View 的 enable 属性不影响 onTouchEvent 的默认返回值，哪怕一个 View 是 disable 状态，只要他的 clickable 或者 longClickable 有一个为 true， 那么他的 onTouchEvent 就返回true。 onClick 会发生的前提是 View 是可点击的，并且它收到了 down 和 up 事件。 事件传递过程是有外向内的，即事件总是先传递给父元素，然后在由父元素分发给子 View，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外（解决滑动冲突，内部拦截法）。 事件的传递过程：Activity -&gt; Window(PhoneWindow) -&gt; View -&gt; dispatchTouchEvent -&gt; onInterceptTouchEvent -&gt; onTouchEvent。 当一个 View 需要处理事件时，如果它设置了 onTouchListener，那么 onTouchListener 中的 onTouch 方法会被回调。这时事件如何处理要看 onTouch 的返回值，返回 false，则当前 View 的 onTouchEvent 被调用，true， 则不调用。View 的 onTouchListener 方法优先级高于 onTouchEvent；onClickListener（需要完成有 up 操作） 方法在 onTouchEvent 中被调用，因此，onClickListener 处于事件传递的尾端。]]></content>
>>>>>>> c1e1d1e28407f3ab1f40fc8a12b186e1bb22e897
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 在一个应用中启动另外一个应用]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Android 在一个应用中启动另外一个应用Android 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动. 综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式. 1. 通过 APP 启动另一个 APP1234String packageName = &quot;com.android.calendar&quot;;Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);intent.putExtra(&quot;type&quot;, true);startActivity(intent); 上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException. 通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 android.intent.action.MAIN 的 Activity 启动. 这里介绍两种方式,检测目标应用是否已经安装 方法一: 1234Intent intent = getPackageName().getLaunchIntentForPackage(packageName);if (intent == null) &#123; // 这里判断 Intent 为空, 说明应用不存在 &#125; 方法二: 1234PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);if (packageInfo == null) &#123; // 这里如果 packageInfo 为 null, 说明应用不存在&#125; 2. 打开另外一个 APP 指定的 Activity1234Intent intent = new Intent();ComponentName componeneName = new ComponeneName(&quot;com.android.calendar&quot;, &quot;com.android.calendar.LaunchActivity&quot;);intent.setComponent(componeneName);startActivity(intent); 值得注意: 需要将目标 Activity 的 android:export=”true” 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错 123Caused by: java.lang.SecurityException: Permission Denial: starting Intent &#123; cmp=com.example.fm/.MainFragmentActivity (has extras) &#125; from ProcessRecord&#123;39282a97 11545:com.xing.toolbardemo1/u0a71&#125; (pid=11545, uid=10071) not exported from uid 10067 在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦 12 Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class &#123;com.example.fm/com.example.fm.MainFragmentActivity&#125;; have you declared this activity in your AndroidManifest.xml?]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Dependencies Library Resolve]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-Studio-Dependencies-Library-Resolve%2F</url>
    <content type="text"><![CDATA[在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了. 先说点不正经的: 你可以把你自己引入的包去掉,使用依赖包 放弃治疗 哈哈,言归正传: 当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 build.gradle 中将我们不需要的包删除掉. 举个栗子:当我使用 com.squareup.retrofit2:adapter-rxjava:2.1.0 时, 它默认依赖使用 RxJava 1.5.0 版本. 当我使用 io.reactivex.rxjava2:rxjava:2.0.6 时, 就会引起包冲突. 解决方案:build.gradle 1234567891011...dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) compile (&apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;)&#123; exclude group: &apos;io.reactivex&apos; &#125; compile &apos;io.reactivex.rxjava2:rxjava:2.0.6&apos; compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git command]]></title>
    <url>%2F2019%2F04%2F16%2Fgit-command%2F</url>
<<<<<<< HEAD
    <content type="text"><![CDATA[Git 命令 修改记录 修改时间 备注 添加删除远程分支 2018年07月26日13:59:22 删除远程分支命令 更新fork仓库 2018年08月10日14:16:08 添加fork的仓库，从主仓库更新代码的命令 整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^ Git 文件的三种状态 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。 已修改：表示修改了某个文件，但还没有提交保存 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。 远程仓库与本地代码的配置将本地已经有的项目上传到远程空仓库中 123456cd &lt;project path&gt;git initgit remote add origin &lt;远程仓库地址&gt;git add .git commit -m &apos;提交日志&apos;git push -u origin master Git 基本配置 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。 使用 --global 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 --global 选项重新配置，新的配置位于当前项目的 .git/config 文件中。 12git config --global user.name &apos;&apos;yourname&apos;&apos;git config --global user.email yourname@gmail.com 基础命令 git init 通过此命令会在当前目录创建一个.git的隐藏目录，这是git的第一步。 git status git status是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行git commit 还是执行git add 操作。 git add 将一个或多个文件添加到 git仓库中，只有通过 git add 添加的文件才会被版本控制管理。 添加单个文件 git add HelloWorld2.java 添加多个文件 git add --a 添加当前目录所有文件 git add . git rm –cached 将文件从git追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除 git commit 执行过 git add 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交 带 log 的提交： git commit -m &#39;first commit&#39; 通过编辑器提交: git commit 带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好. git log 查看历史提交记录， 包括提交人、时间、信息、信息指纹等. 查看提交记录： git log 单行展示记录： git log --pretty=oneline 展示全部信息： git log --pretty=fuller git clone &lt;远程仓库地址&gt; 拉取远程仓库代码,此项目并不一定是你所创建 例如： git clone git@github.com:bboyfeiyu/AndroidEventBus.git 执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码 git remote 将本地已经init过的工程链接到远程的空仓库中，以此来完成远程版本库的创建 链接远程版本库： git remote add origin &lt;远程地址&gt; 修改 github 或是其他仓库 username (指向用户)时 使用 git remote set-url 去修改已经存在的远程仓库地址 因为 ssh 和 https 不同,因此操作也不同,如下 http: https://github.com/USERNAME/respository.git ssh `git@github.com:USERNAME/respository.git` 切换远程URL 打开终端 切换到本地工程文件夹 列出当前远程名称 git remote -v 切换远程URL, SSH to HTTPS $ git remote set-url origin https://github.com/USERNAME/repository.git 校验远程地址是否正确 1234$ git remote -v# Verify new remote URL&gt; origin https://github.com/USERNAME/repository.git(fetch)&gt; origin https://github.com/USERNAME/repository.git(push) git branch 分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作 查看分支： git branch 查看带提交信息的分支信息： git branch -v 创建分支： git branch &lt;分支名称&gt; 创建并切换分支： git branch -b &lt;分支名称&gt; 切换分支： git checkout &lt;分支名称&gt; 推送分支： git push origin &lt;分支名称&gt; 删除分支： git branch -d &lt;分支名称&gt; 删除远程分支： git push origin :&lt;分支名称&gt; 合并分支： git merge &lt;分支名称&gt; git push 推送本地修改到远端服务器 git push origin master 有时因两个独立的历史，会导致推送无法达成， 通常在 git pull 时会提示 fatal: refusing to merge unrelated histories // 拒绝合并无关历史 这时可是使用 git pull origin master --allow-unrelated-histories 来解决。 git tag 会列出所有的 tag 标签信息 在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，这是一个很重要的功能 建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。 查看本地/远程 tag 标签：git tag 查看模糊 tag 标签： git tag -l &#39;v1.4.2.*&#39; 查看备注 tag 标签： git tag -ln 查看标签信息： git show &lt;标签名&gt; 创建本地 tag 标签： git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot; 删除本地 tag 标签： git tag -d &lt;标签名&gt; 推送远程 tag 标签： git push origin &lt;标签名&gt; 推送全部 tag 标签： git push origin -tags 删除远程 tag 标签： git push origin :refs/tags/&lt;标签名&gt; 查看远程机状态 git remote 用来管理， fork 的项目，与主项目的更新操作 12345git remote -vgit remote add upstream git@github.com:XXX/XXX.gitgit fetch upstreamgit merge upstream/mastergit push 使用中的一些技巧命名别名复杂并超长的命令，可以通过起别名的方式方便在终端中书协 123git config --global alias.ci commitgit config --global alias.ck checkoutgit config --global alias.st status 然后就可以很愉快的使用git命令了。1git st]]></content>
    <content type="text"><![CDATA[Git 命令 修改记录 修改时间 备注 添加删除远程分支 2018年07月26日13:59:22 删除远程分支命令 更新fork仓库 2018年08月10日14:16:08 添加fork的仓库，从主仓库更新代码的命令 整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^ Git 文件的三种状态 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。 已修改：表示修改了某个文件，但还没有提交保存 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。 远程仓库与本地代码的配置将本地已经有的项目上传到远程空仓库中 123456cd &lt;project path&gt;git initgit remote add origin &lt;远程仓库地址&gt;git add .git commit -m &apos;提交日志&apos;git push -u origin master Git 基本配置 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。 使用 --global 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 --global 选项重新配置，新的配置位于当前项目的 .git/config 文件中。 12git config --global user.name &apos;&apos;yourname&apos;&apos;git config --global user.email yourname@gmail.com 基础命令 git init 通过此命令会在当前目录创建一个.git的隐藏目录，这是git的第一步。 git status git status是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行git commit 还是执行git add 操作。 git add 将一个或多个文件添加到 git仓库中，只有通过 git add 添加的文件才会被版本控制管理。 添加单个文件 git add HelloWorld2.java 添加多个文件 git add --a 添加当前目录所有文件 git add . git rm –cached 将文件从git追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除 git commit 执行过 git add 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交 带 log 的提交： git commit -m &#39;first commit&#39; 通过编辑器提交: git commit 带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好. git log 查看历史提交记录， 包括提交人、时间、信息、信息指纹等. 查看提交记录： git log 单行展示记录： git log --pretty=oneline 展示全部信息： git log --pretty=fuller git clone &lt;远程仓库地址&gt; 拉取远程仓库代码,此项目并不一定是你所创建 例如： git clone git@github.com:bboyfeiyu/AndroidEventBus.git 执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码 git remote 将本地已经init过的工程链接到远程的空仓库中，以此来完成远程版本库的创建 链接远程版本库： git remote add origin &lt;远程地址&gt; git remote set-url &lt;仓库地址&gt; SSH 和 HTTPS 方式切换 1234# ssh to https$ git remote set-url origin https://github.com/USERNAME/repository.git# https to ssh$ git remote set-url origin git@github.com:USERNAME/repository.git 可以使用 git remote -v 来检查当前仓库地址 12&gt; origin git@github.com:username/repository.git (fetch)&gt; origin git@github.com:username/repository.git (push) SSH 和 HTTPS 的区别： 使用 SSH 方式需要在本地配置一个密钥，具体可参见多个 SSH 公钥提交代码到不同平台中介绍；而使用 HTTPS 的方式操作简单，弊端是需要经常输入密码。 git branch 分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作 查看分支： git branch 查看带提交信息的分支信息： git branch -v 创建分支： git branch &lt;分支名称&gt; 创建并切换分支： git branch -b &lt;分支名称&gt; 切换分支： git checkout &lt;分支名称&gt; 推送分支： git push origin &lt;分支名称&gt; 删除分支： git branch -d &lt;分支名称&gt; 删除远程分支： git push origin :&lt;分支名称&gt; 合并分支： git merge &lt;分支名称&gt; git push 推送本地修改到远端服务器 git push origin master 有时因两个独立的历史，会导致推送无法达成， 通常在 git pull 时会提示 fatal: refusing to merge unrelated histories // 拒绝合并无关历史 这时可是使用 git pull origin master --allow-unrelated-histories 来解决。 git tag 会列出所有的 tag 标签信息 在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，这是一个很重要的功能 建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。 查看本地/远程 tag 标签：git tag 查看模糊 tag 标签： git tag -l &#39;v1.4.2.*&#39; 查看备注 tag 标签： git tag -ln 查看标签信息： git show &lt;标签名&gt; 创建本地 tag 标签： git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot; 删除本地 tag 标签： git tag -d &lt;标签名&gt; 推送远程 tag 标签： git push origin &lt;标签名&gt; 推送全部 tag 标签： git push origin -tags 删除远程 tag 标签： git push origin :refs/tags/&lt;标签名&gt; 查看远程机状态 git remote 用来管理， fork 的项目，与主项目的更新操作 12345git remote -vgit remote add upstream git@github.com:XXX/XXX.gitgit fetch upstreamgit merge upstream/mastergit push 使用中的一些技巧命名别名复杂并超长的命令，可以通过起别名的方式方便在终端中书协 123git config --global alias.ci commitgit config --global alias.ck checkoutgit config --global alias.st status 然后就可以很愉快的使用git命令了。1git st]]></content>
>>>>>>> c1e1d1e28407f3ab1f40fc8a12b186e1bb22e897
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个Android IoT App]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid-IoT-App%2F</url>
    <content type="text"><![CDATA[构建 Android IoT App本文翻译自Building IoT APP for Android Things in 3 step 前言这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统– Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 Android Things and how it works 是很有必要的。 名词索引Android IoT App ： 安卓物联网应用 Raspberry Pi 3 ： 树莓派 3 目标这篇文章的目标是： 使用 Android Things 构建一个简单的 RGB Led 控制器 使用 Android API 构建 Android IoT UI 开发 我们会使用 Raspberry Pi 3 作为 IoT 开发板,你也可以使用其他的开发板去开发 Android Things。 此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。 步骤一通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 Raspberry， 每个颜色一个，原理图如下： 共阳极 RGB LED 灯非常常见，因此 Raspberry Pi 3 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 Raspberry 引脚： Pin 29 Pin 31 Pin 33 这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。 现在，我们使用 Android Studio 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle : 123dependencies &#123; provided &apos;com.google.android.things:androidthings:0.1-devpreview&apos;&#125; Android Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 RGBThingsActivity 类，并在 onCreate 方法中处理 Pin 通信。 步骤二使用 GPIO 引脚与 RGB LED 传递信息。 GPIO 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。 Android Things SDK 提供了一个 PeripheralManagerService 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值： 1234567891011121314try &#123; PeripheralManagerService manager = new PeripheralManagerService(); blueIO = manager.openGpio(&quot;BCM5&quot;); blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); greenIO = manager.openGpio(&quot;BCM6&quot;); greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH); redIO = manager.openGpio(&quot;BCM13&quot;); redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); redIO.setValue(false); blueIO.setValue(false); greenIO.setValue(false);&#125; catch (IOException e) &#123; Log.w(TAG, &quot;Unable to access GPIO&quot;, e);&#125; 这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 Respberry Pin reference ,下图： 可以了解到 Respberry Pi 3 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为： 1blueIO = manager.openGpio(&quot;BCM5&quot;); 开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。 步骤三Android Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Switch android:text=&quot;Red&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchRed&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;Switch android:text=&quot;Green&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchGreen&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;Switch android:text=&quot;Blue&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchBlue&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;/LinearLayout&gt; 在 onCreate 方法中，我们设置 layout 布局： 123456@Overridepublic void onCreate (Bundle savedInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ...&#125; 处理用户开关： 1234567891011Switch switchRed = (Switch)findViewById(R.id.switchRed);switch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener()&#123; @Override public void onCheckedChanged (CompoundButton buttonView, boolean isChecked)&#123; try &#123; redIO.setValue(!isChecked); &#125; catch (IOException e) &#123; Log.w(TAG,&quot;Red GPIO Error&quot;, e); &#125; &#125;&#125;); 我们必须为其他引脚重复同一段代码。最终结果如下： 因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。 最终结果展示–需要翻墙 youtube 上观看 最后，要使用我们的应用程序，我们必须在 Manifest.xml 文件中条件： 1&lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt; 并且声明我的 Activity 是一个 IoT Activity， 启动脚本为： 1234&lt;intent-filter&gt; &lt;category android:name=&quot;android.intent.category.IOT_LAUNCHER&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT”/&gt;&lt;/intent-filter&gt; 总结文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。 使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.]]></content>
      <tags>
        <tag>Android Things</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins + gradle + git 构建 Android CI 构建环境]]></title>
    <url>%2F2019%2F04%2F16%2FJenkins-gradle-git-%E6%9E%84%E5%BB%BA-Android-CI-%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。 目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。 然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。 因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。 对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。 对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。 CI 的基本工作流程如下： 我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。 准备工作本文使用 Linux Ubuntu 系统为大家介绍环境的搭建 环境工具1. PC 机(mac/linux) 2. Java JDK 3. Android SDK 4. Gradle 5. Git 6. Tomcat 7. Jenkins 环境搭建Java 环境 安装Java JDK, Android SDK, Gradle 可从AndroidDevTools处下载获取。 git 安装git 可通过终端进行安装123sudo add-apt-repository ppa:git-core/ppasudo apt-get updatesudo apt-get install git 安装完成之后通过git --version 检查是否成功 安装后 git 存储在 /usr/bin/git下 Jenkins通过 Jenkins 官方网站下载最新Jenkins.war包 环境变量打开 vi /etc/profile 将下列语句添加在文件的末尾后， 执行 esc-&gt;:wq 其中环境位置根据自己的所在位置进行相应的更改 启动激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins 将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。 启动后，在浏览器中输入： localhost:8080/jenkins 插件安装系统管理-&gt; 插件管理-&gt;可选插件： 在搜索框中搜索以下插件，并进行安装 git plugingitlab plugingrade pluginAndroid Lint PluginBuild Pipeline pluginbuild timeout pluginbuild name pluginchange assembly-version plugincredentials binding plugindescription setter pluginDynamic parameter pluginEmail Extension pluginFindBugs pluginJaCoco pluginUnit attachments pluginProject Description pluginTimestamperWorkspace cleanup plugin 安装完成后，重启。 系统设置系统管理-&gt;系统设置： 配置Android 环境，将地址指向本机的 SDK 目录 系统管理-&gt;全局工具配置 配置 Java， Git ， Gradle 目录等 JDK： Git： Gradle： 到此，环境配置，已基本完成。 下面我们开始进行项目够将操作 项目构建创建Job新建-&gt;构建一个自由风格的软件项目: 参数化构建通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。 在这里我们先看看 build.gradle 中的构建信息: 在项目的 moudle 下 build.gradle 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def getDate () &#123; def date = new Date() def formattedDate = date.format(&quot;yyyyMMddHHmm&quot;) return formattedDate&#125;def verName = APP_VERSIONdef verCode = 14android &#123; .... signingConfigs &#123; release &#123; keyAlias &apos;&apos; keyPassword &apos;&apos; storeFile file (&apos;&apos;) storePassword &apos;&apos; &#125; &#125; defaultConfig &#123; applicationId &quot;cn.zhuangbudong.example&quot; minSdkVersion 18 targetSdkVersion 25 multiDexEnabled true versionCode verCode versionName verName resValues(&quot;string&quot;, &apos;app_version&apos;, verName) &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.release minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; lintOptions &#123; abortOnError false &#125; dexOptions &#123; javaMaxHeapSize &apos;2g&apos; &#125;applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def newName def timeNow def oldFile = output.outputFile def outDirectory = oldFile.parent if (&quot;true&quot;.equals(IS_JENKINS)) &#123; timeNow = JENKINS_TIME outDirectory = &quot;/media/nexd/work/android/package/release/&quot; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; &#125; else &#123; timeNow = getDate() if (variant.buildType.name.equals(&apos;debug&apos;)) &#123; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_debug.apk&quot; &#125; else &#123; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; &#125; &#125; output.outputFile = new File(outDirectory, newName) &#125;&#125; &#125;&#125; gradle.properties: 123APP_VERSION=2.0.2IS_JENKINS=falseJENKINS_TIME=&apos;&apos; 在工程中添加以上代码，并在Jenkins中为这些参数赋值。 下面介绍 Jenkins 参数配置 勾选参数化构建过程，如下图： 按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致 源码管理此处负责从版本库中拉去最新的代码 此处如果需要验证，点击 Add， 选择： Username with password 在对应窗口输入用户名和密码信息 点击添加。 使用 gitlab 进行源码库管理。 触发器触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。 构建环境此处只是在Jenkins在打包时，配置任务名称即可。如下图： 构建这里是最重要滴，配置以下命令，才能进行打包签名等等。 如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。 同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。 构建后操作当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图： 12345678910111213&lt;hr/&gt;(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;项目名称：$&#123;PROJECT_NAME&#125;&lt;br/&gt;&lt;hr/&gt;构建编号：$&#123;BUILD_NUMBER&#125;&lt;br/&gt;&lt;hr/&gt;构建状态：$&#123;BUILD_STATUS&#125;&lt;br/&gt;&lt;hr/&gt;触发原因：$&#123;CAUSE&#125;&lt;br/&gt;&lt;hr/&gt;测试报告：&lt;a href=&quot;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&quot;&gt;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建日志地址：&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console/&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建地址：&lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建报告：&lt;a href=&quot;$&#123;BUILD_URL&#125;testReport&quot;&gt;$&#123;BUILD_URL&#125;testReport&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;变更集:$&#123;JELLY_SCRIPT,template=&quot;html&quot;&#125;&lt;br/&gt;&lt;hr/&gt; 开始构建回到 Jenkins 首页，点击创建的项目，点击 build with parameters: 点击开始构建，启动 Jenkins 构建任务。 构建成功时，显示为蓝色， 失败为红色，如下图： 构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。 谢谢~]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb command]]></title>
    <url>%2F2019%2F04%2F16%2Fadb-command%2F</url>
    <content type="text"><![CDATA[查看PID 1adb shell ps 查看日志 12345全部日志adb logcat按照 PID 筛选日志adb logcat | grep &lt;PID&gt; 查询链接设备 1adb devices 重启机器 1adb reboot 杀死进程服务 1adb kill-server 重启进程服务 1adb start-server 获取机器 Mac 地址 1adb shell cat /sys/class/net/wlan0/address 安装 APK 12345678普通安装adb install &lt;file path&gt;保留数据和缓存文件adb install -r &lt;file path&gt;安装到 SD 卡上adb install -s &lt;file path&gt; 卸载 APK 12345普通卸载adb uninstall &lt;package name&gt;保留数据和缓存文件adb uninstall -k &lt;package name&gt; 启动应用 1adb shell am start -n &lt;package name&gt;/.&lt;activity_class_name&gt; 查看 CPU 占用率 1234567adb shell top查看内存占用前 6 的 appadb shell top -m 6刷新一次内存adb shell top -n 1 杀死进程 1adb shell kill &lt;pid&gt; 将 System 分区重新挂在为可读写分区 1adb remount 从本地复制文件到设备 1adb push &lt;local&gt; &lt;remote&gt; 从设备复制文件到本地 1adb pull &lt;remote&gt; &lt;local&gt; 查看 WiFi 密码 1adb shell cat /data/misc/wifi/*.conf 查看 bug 报告 1adb bugreport 跑 monkey 1adb shell monkey -v -p your.package.name 500 截图 1adb shell screencap -p /sdcard/screenshot.png 录屏 1adb shell screenrecord /sdcard/demo.mp4 查看安装列表 1adb shell pm list packages 查看内存占用 1adb shell dumpsys meminfo &lt;package&gt; -d 查询栈信息 12345adb shell dumpsys activity// 获取自己应用adb shell dumpsys activity | grep &lt;package&gt;// 获取处于栈顶的 activityadb shell dumpsys activity | grep mFocusedActivity]]></content>
    <content type="text"><![CDATA[查看PID 1adb shell ps 查看日志 12345全部日志adb logcat按照 PID 筛选日志adb logcat | grep &lt;PID&gt; 查询链接设备 1adb devices 重启机器 1adb reboot 杀死进程服务 1adb kill-server 重启进程服务 1adb start-server 获取机器 Mac 地址 1adb shell cat /sys/class/net/wlan0/address 安装 APK 12345678普通安装adb install &lt;file path&gt;保留数据和缓存文件adb install -r &lt;file path&gt;安装到 SD 卡上adb install -s &lt;file path&gt; 卸载 APK 12345普通卸载adb uninstall &lt;package name&gt;保留数据和缓存文件adb uninstall -k &lt;package name&gt; 启动应用 1adb shell am start -n &lt;package name&gt;/.&lt;activity_class_name&gt; 查看 CPU 占用率 1234567adb shell top查看内存占用前 6 的 appadb shell top -m 6刷新一次内存adb shell top -n 1 杀死进程 1adb shell kill &lt;pid&gt; 将 System 分区重新挂在为可读写分区 1adb remount 从本地复制文件到设备 1adb push &lt;local&gt; &lt;remote&gt; 从设备复制文件到本地 1adb pull &lt;remote&gt; &lt;local&gt; 查看 WiFi 密码 1adb shell cat /data/misc/wifi/*.conf 查看 bug 报告 1adb bugreport 跑 monkey 1adb shell monkey -v -p your.package.name 500 截图 1adb shell screencap -p /sdcard/screenshot.png 录屏 1adb shell screenrecord /sdcard/demo.mp4 查看安装列表 1adb shell pm list packages &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 安装证书 1adb shell am start -n com.android.certinstaller/.CertInstallerMain -a android.intent.action.VIEW -t application/x-x509-ca-cert file:///sdcard/cacert.cer ======= 查看内存占用 1adb shell dumpsys meminfo &lt;package&gt; -d 查询栈信息 12345adb shell dumpsys activity// 获取自己应用adb shell dumpsys activity | grep &lt;package&gt;// 获取处于栈顶的 activityadb shell dumpsys activity | grep mFocusedActivity f9adb0c31383a6ee73b1b79bc3661b2e25cff86a]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2Fschedule%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[sitemap]]></title>
    <url>%2Fsitemap%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2Fschedule%2Findex.html</url>
    <content type="text"></content>
</search>
