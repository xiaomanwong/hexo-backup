<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OkHttp Intercept.md]]></title>
    <url>%2F2019%2F04%2F30%2FOkHttp-Intercept%2F</url>
    <content type="text"><![CDATA[OkHttp InterceptorOKHttp 在开发中经常用到,这里介绍一下 OKHttp 的拦截器(interceptor)的几个使用例子 要是用拦截器很简单,我们只需要自定义一个 interceptor 类, 并实现 Interceptor 接口, 同时重写 intercept 方法. 这里介绍两种 Interceptor 的实例 Log 日志 (LogInterceptor)Log 在开发调试中的重要性, 不言而喻, 一个好的日志数据,能够为开发时提供很多帮助,可以通过 Log 来获取当前程序的执行状态, 顺序等等. 这里介绍的 Log 日志拦截器,主要是负责在网络请求时,截获请求中的信息,并将请求信息以 Log 的方式输出到控制台上,可展现当前请求地址,请求参数,以及请求结果等. 话不多说, 上代码. 1234567891011121314151617181920212223242526272829303132333435363738394041/*** 自定义 log 拦截器,输入请求地址,请求参,请求结果*/public class LogInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; // 拦截请求信息,获取请求地址及请求参数 Request request = chain.request(); long t1 = System.nanoTime(); // 获取请求方式 String method = request.method(); if ("POST".equals(method)) &#123; StringBuilder sb = new StringBuilder(); if (request.body() instanceof FormBody) &#123; FormBody body = (FormBody) request.body(); for (int i = 0; i &lt; body.size(); i++) &#123; sb.append(body.encodedName(i) + "=" + body.encodedValue(i) + ","); &#125; sb.delete(sb.length() - 1, sb.length()); LogUtils.d(TAG, String.format("Sending request %s on %s %n%s %nRequestParams:&#123;%s&#125;", request.url(), chain.connection(), request.headers(), sb.toString())); &#125; &#125; else &#123; LogUtils.d(TAG, String.format("Sending request %s on %s %n%s", request.url(), chain.connection(), request.headers())); &#125; // 获取响应信息 Response response = chain.proceed(request); long t2 = System.nanoTime(); LogUtils.d(TAG, String.format("Received response for %s in %.1fms%n%s", response.request().url(), (t2 - t1) / 1e6d, response.headers())); MediaType contentType = response.body().contentType(); String content = response.body().string(); LogUtils.d(TAG, content); ResponseBody wrappedBody = ResponseBody.create(contentType, content); return response.newBuilder().body(wrappedBody).build(); &#125; &#125; 加参加参的意义在于,在请求过程中, 需要传递一些基本参数,这些参数是基本保持不变的, 而这些参数又是后台需要校验的依靠,我们俗称他们为公参, 如果在请求过程中在每一个接口里面都去添加这些参数,显得非常繁琐,而且麻烦,后续人员接手,又会不知所措,维护起来相当不方便. 因此,在这里我们还是通过请求拦截器,通过拦截器去添加这些参数. 公参拦截器在请求中,增加一些公共的参数. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public class CommonParamsInterceptor implements Interceptor &#123; private Map&lt;String, String&gt; queryParamsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; paramsMap = new HashMap&lt;&gt;(); private Map&lt;String, String&gt; headerParamsMap = new HashMap&lt;&gt;(); private List&lt;String&gt; headerLinesList = new ArrayList&lt;&gt;(); @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); // process header params inject Headers.Builder headerBuilder = request.headers().newBuilder(); if (headerParamsMap.size() &gt; 0) &#123; Iterator iterator = headerParamsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); headerBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; if (headerLinesList.size() &gt; 0) &#123; for (String line : headerLinesList) &#123; headerBuilder.add(line); &#125; requestBuilder.headers(headerBuilder.build()); &#125; // process header params end // process queryParams inject whatever it's GET or POST if (queryParamsMap.size() &gt; 0 &amp;&amp; "GET".equals(request.method())) &#123;// if (queryParamsMap.size() &gt; 0) &#123; request = injectParamsIntoUrl(request, requestBuilder, queryParamsMap); &#125; // process post body inject if (paramsMap != null &amp;&amp; paramsMap.size() &gt; 0 &amp;&amp; "POST".equals(request.method())) &#123; if (request.body() instanceof FormBody) &#123; FormBody.Builder newFormBodyBuilder = new FormBody.Builder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); newFormBodyBuilder.add((String) entry.getKey(), (String) entry.getValue()); &#125; &#125; FormBody oldFormBody = (FormBody) request.body(); int paramSize = oldFormBody.size(); if (paramSize &gt; 0) &#123; for (int i = 0; i &lt; paramSize; i++) &#123; newFormBodyBuilder.add(oldFormBody.name(i), oldFormBody.value(i)); &#125; &#125; requestBuilder.post(newFormBodyBuilder.build()); request = requestBuilder.build(); &#125; else if (request.body() instanceof MultipartBody) &#123; MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); multipartBuilder.addFormDataPart((String) entry.getKey(), (String) entry.getValue()); &#125; List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; requestBuilder.post(multipartBuilder.build()); request = requestBuilder.build(); &#125; &#125; return chain.proceed(request); &#125; private boolean canInjectIntoBody(Request request) &#123; if (request == null) &#123; return false; &#125; if (!TextUtils.equals(request.method(), "POST")) &#123; return false; &#125; RequestBody body = request.body(); if (body == null) &#123; return false; &#125; MediaType mediaType = body.contentType(); if (mediaType == null) &#123; return false; &#125; if (!TextUtils.equals(mediaType.subtype(), "x-www-form-urlencoded")) &#123; return false; &#125; return true; &#125; // func to inject params into url private Request injectParamsIntoUrl(Request request, Request.Builder requestBuilder, Map&lt;String, String&gt; paramsMap) &#123; HttpUrl.Builder httpUrlBuilder = request.url().newBuilder(); if (paramsMap.size() &gt; 0) &#123; Iterator iterator = paramsMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry) iterator.next(); httpUrlBuilder.addEncodedQueryParameter((String) entry.getKey(), (String) entry.getValue()); &#125; requestBuilder.url(httpUrlBuilder.build()); return requestBuilder.build(); &#125; return request; &#125; private static String bodyToString(final RequestBody request) &#123; try &#123; final RequestBody copy = request; final Buffer buffer = new Buffer(); if (copy != null) copy.writeTo(buffer); else return ""; return buffer.readUtf8(); &#125; catch (final IOException e) &#123; return "did not work"; &#125; &#125; public static class Builder &#123; CommonParamsInterceptor interceptor; public Builder() &#123; interceptor = new CommonParamsInterceptor(); &#125; public Builder addParam(String key, String value) &#123; interceptor.paramsMap.put(key, value); return this; &#125; public Builder addParamsMap(Map&lt;String, String&gt; paramsMap) &#123; interceptor.paramsMap.putAll(paramsMap); return this; &#125; public Builder addHeaderParam(String key, String value) &#123; interceptor.headerParamsMap.put(key, value); return this; &#125; public Builder addHeaderParamsMap(Map&lt;String, String&gt; headerParamsMap) &#123; interceptor.headerParamsMap.putAll(headerParamsMap); return this; &#125; public Builder addHeaderLine(String headerLine) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); return this; &#125; public Builder addHeaderLinesList(List&lt;String&gt; headerLinesList) &#123; for (String headerLine : headerLinesList) &#123; int index = headerLine.indexOf(":"); if (index == -1) &#123; throw new IllegalArgumentException("Unexpected header: " + headerLine); &#125; interceptor.headerLinesList.add(headerLine); &#125; return this; &#125; public Builder addQueryParam(String key, String value) &#123; interceptor.queryParamsMap.put(key, value); return this; &#125; public Builder addQueryParamsMap(Map&lt;String, String&gt; queryParamsMap) &#123; interceptor.queryParamsMap.putAll(queryParamsMap); return this; &#125; public CommonParamsInterceptor build() &#123; return interceptor; &#125; &#125;&#125; 加签拦截器互联网是一个开放的环境,危险无处不在,加密通信是安全的基础. 加密的方式又有很多,比如对称加密/非对称加密/Hash(严格的说不是加密),这里先不对加密进行介绍,我们聊聊加签; 加签,其实就是给报文做一个摘要,相同的签名算法得到的摘要是相同的,比如MD5, SH1, SH256等, 简单的加签并不能防止篡改,因为攻击者可以篡改后,自己生成新的签名.服务端验签还是可以通过的,因此加签时一定要包含一些私有的东西,比如私钥. 这里介绍一种加签方式, 加密规则 根据请求参数 key 进行排序 按排好的顺序组装成 key=value&amp;key=value 形式的字符串 将上述字符串拼接 mid, timestamp, key(私钥) ,最终形成 key=value&amp;key=value&amp;mid&amp;timestamp&amp;key 的字符串 将字符串 md5 32位小写加密, 生成 auth. 一个简单的加签逻辑就是这样,下面代码就是对这种规则的实现,看代码↓↓↓↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261public class AuthorizeInterceptor implements Interceptor &#123; private static final String TAG = "AuthorizeInterceptor"; /** * 生成 auth 的私钥 */ private String authKey; /** * 当前设备 mid,用来生成 auth * 数据由 Builder 类传入 */ private String mid = ""; private AuthorizeInterceptor() &#123; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); Request.Builder requestBuilder = request.newBuilder(); String url = request.url().toString(); LogUtils.d(TAG, url); if ("POST".equals(request.method())) &#123; request = injectionParamIntoBody(request, requestBuilder); &#125; else if ("GET".equals(request.method())) &#123; request = injectionAuthIntoUrl(request, requestBuilder); &#125; return chain.proceed(request); &#125; /** * GET 请求方式, 生成授权和添加时间戳 * * @param request * @param requestBuilder * @return */ private Request injectionAuthIntoUrl(Request request, Request.Builder requestBuilder) &#123; //获取到请求地址api HttpUrl newHttpUrl = request.url(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); //通过请求地址(最初始的请求地址)获取到参数列表 Set&lt;String&gt; parameterNames = newHttpUrl.queryParameterNames(); long timestamp = System.currentTimeMillis(); for (String key : parameterNames) &#123; //循环参数列表 if (!"basic".equals(key)) &#123; // 获取参数value, String paramValue = newHttpUrl.queryParameter(key); if (!TextUtils.isEmpty(paramValue)) &#123; authMap.put(key, paramValue); &#125; &#125; &#125; LogUtils.d(TAG, "===================================== Get 开始生成 auth =========================================="); HttpUrl.Builder newBuilder = request.url().newBuilder() .addEncodedQueryParameter("auth", assembleAuth(authMap, timestamp, false)) .addEncodedQueryParameter("timestamp", String.valueOf(timestamp)); requestBuilder.url(newBuilder.build()); return requestBuilder.build(); &#125; /** * 将参数注入到 POST 请求的 body 中 * * @param request * @param requestBuilder * @return */ private Request injectionParamIntoBody(Request request, Request.Builder requestBuilder) &#123; if (request.body() instanceof FormBody) &#123; // 处理正常表单请求方式 FormBody oldFormBody = (FormBody) request.body(); return assembleFormBody(request, oldFormBody, requestBuilder); &#125; else if (request.body() instanceof MultipartBody) &#123; return assembleMultipartBody(request, requestBuilder); &#125; else &#123; return request; &#125; &#125; /** * 构建流媒体参数的 body * * @param request * @param builder * @return */ private Request assembleMultipartBody(Request request, Request.Builder builder) &#123; // 处理流的请求方式 MultipartBody body = (MultipartBody) request.body(); TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); long timestamp = System.currentTimeMillis(); // 获取参数 key 及 value 数据, 将数据写入到 TreeMap 中进行排序 if (body != null &amp;&amp; body.parts().size() &gt; 0) &#123; for (MultipartBody.Part part : body.parts()) &#123; // 只处理 contentType 为空,或为 text 的情况, image 上传图片的字段,不进行处理 if (part.body().contentType() == null || !"image".equals(part.body().contentType().type()) || "text".equals(part.body().contentType().type())) &#123; Headers headers = part.headers(); // 从 header 中获取 Key, form-data; name= 的字段过滤获取key // 筛选掉 basic, 获取到当前 header,对应的 RequestBody, 通过 buffer 的方式,获取到 value // 将 key 和 value 填充到 TreeMap 中 for (int i = 0; i &lt; headers.names().size(); i++) &#123; String headerName = headers.value(i); if (headerName.contains("form-data; name=")) &#123; String key = headerName.replace("form-data; name=", "").replace("\"", ""); if (!"basic".equals(key)) &#123; String value = body2String(part.body()); if (!TextUtils.isEmpty(value)) &#123; authMap.put(key, body2String(part.body())); &#125; &#125; &#125; &#125; &#125; &#125; &#125; LogUtils.d(TAG, "============================ MultipartBody 准备生成 Auth ====================================="); MultipartBody.Builder multipartBuilder = new MultipartBody.Builder().setType(MultipartBody.FORM); multipartBuilder.addFormDataPart("auth", assembleAuth(authMap, timestamp, false)); multipartBuilder.addFormDataPart("timestamp", String.valueOf(timestamp)); List&lt;MultipartBody.Part&gt; oldParts = ((MultipartBody) request.body()).parts(); if (oldParts != null &amp;&amp; oldParts.size() &gt; 0) &#123; for (MultipartBody.Part part : oldParts) &#123; multipartBuilder.addPart(part); &#125; &#125; builder.post(multipartBuilder.build()); return builder.build(); &#125; /** * 构建 Auth 数据 * &lt;p&gt; * TreeMap 数据,按照字母顺序自动排序后,遍历数据,拼接成 key=value&amp;key=value 的形式, * Map 拼接完成后,在其后需要再次拼接上 &amp;mid&amp;timestamp&amp;key * &lt;p&gt; * 最后将数据 MD5 转化为 32 位小写并返回 * * @param treeMap 构建 Auth 的具体数据 * @param timestamp 当前时间戳 * @param isNeedDecode 是否需要解码 * @return 返回 auth 数据 --- 32位小写 */ private String assembleAuth(TreeMap&lt;String, String&gt; treeMap, long timestamp, boolean isNeedDecode) &#123; StringBuilder stringBuilder = new StringBuilder(); if (treeMap.size() &gt; 0) &#123; for (Map.Entry&lt;String, String&gt; stringStringEntry : treeMap.entrySet()) &#123; try &#123; stringBuilder.append(stringStringEntry.getKey()) .append("=") .append(isNeedDecode ? URLDecoder.decode(stringStringEntry.getValue(), "UTF-8") : stringStringEntry.getValue()) .append("&amp;"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; treeMap.clear(); stringBuilder.append(mid) .append("&amp;") .append(timestamp) .append("&amp;") .append(authKey); LogUtils.d(TAG, stringBuilder.toString()); LogUtils.d(TAG, "============================ Auth 生成完成 ====================================="); return MD5.MD5_32(stringBuilder.toString()); &#125; /** * body 转 string 获取实际参数值 * * @param body Part body * @return part 中写如的参数数据 */ private String body2String(RequestBody body) &#123; if (body != null) &#123; Buffer buffer = new Buffer(); try &#123; body.writeTo(buffer); Charset charset = Charset.forName("UTF-8"); MediaType contentType = body.contentType(); if (contentType != null) &#123; charset = contentType.charset(charset); &#125; assert charset != null; return buffer.readString(charset); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return ""; &#125; /** * 组装 Form 表单请求数据 * * @param request * @param oldFormBody * @param requestBuilder * @return */ private Request assembleFormBody(Request request, FormBody oldFormBody, Request.Builder requestBuilder) &#123; TreeMap&lt;String, String&gt; authMap = new TreeMap&lt;&gt;(); // 遍历请求参数,非空参数,添加到集合中 for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; if (!"basic".equals(oldFormBody.encodedName(i)) &amp;&amp; !TextUtils.isEmpty(oldFormBody.encodedValue(i))) &#123; authMap.put(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; &#125; long timestamp = System.currentTimeMillis(); if (authMap.size() != 0) &#123; LogUtils.d(TAG, "============================ FormBody 准备生成 auth ==========================="); // 生成 auth 数据 FormBody.Builder newFormBody = new FormBody.Builder(); for (int i = 0; i &lt; oldFormBody.size(); i++) &#123; newFormBody.addEncoded(oldFormBody.encodedName(i), oldFormBody.encodedValue(i)); &#125; newFormBody.add("auth", assembleAuth(authMap, timestamp, true)); newFormBody.add("timestamp", String.valueOf(timestamp)); requestBuilder.method(request.method(), newFormBody.build()); return requestBuilder.build(); &#125; return request; &#125; /** * Builder 构造函数,用来设置 Authorize 的相关参数,及创建工作 */ public static class Builder &#123; AuthorizeInterceptor authorizeInterceptor; public Builder() &#123; authorizeInterceptor = new AuthorizeInterceptor(); &#125; public Builder setMid(String mid) &#123; authorizeInterceptor.mid = mid; return this; &#125; public Builder setAuthKey(String key) &#123; authorizeInterceptor.authKey = key; return this; &#125; public AuthorizeInterceptor build() &#123; return authorizeInterceptor; &#125; &#125;&#125; 该加签方式,讲请求参数拼接为 key=value 的方式, 难点在于如何从 OkHttp 中获取这些参数,在 GET 请求和 POST 的处理方式又不同,代码中 POST 请求方式,又会根据请求传递的 contentType 而又有所不同,这里介绍了Form表单提交和 Multipart 上传文件的参数获取方式,其他的请举一反三. 文章有瑕疵, 请大神批评指正.]]></content>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个 ssh 公钥提交代码到不同平台]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%A4%9A%E4%B8%AA-ssh-%E5%85%AC%E9%92%A5%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 多个 SSH 公钥提交代码到不同平台作为一个技术开发人员，免不了在 github 以及 gitlab 以及其他 git 平台上进行代码管理；工作中您可能使用 svn （这不在我们的讨论范围）,也有可能使用 git, 生活中，您可能会将一些内容分享到你的 github 上， 供大家参阅。 git 创建版本库很容易， clone 代码也仅仅是简单的一句 git clone https://github.com/xxxx.git，异或是 git clone git@github.com:xxxxx.git；当然，使用 https 的方式简单易操作（本人认为是一个傻瓜相机），但是通过使用 https 的方式，经常会遇到需要输入账号和密码的情况，这大大的加大了安全问题，虽然某 dear 的图形化工具，会帮助我们 remeber 账号和密码，避免了重复输入，但这不在我们的讨论范围（个人很鄙视使用图形化界面的），接下来要说的就是使用 SSH 的方式来处理 git 的版本管理。 生成 SSH 密钥使用 SSH 创建一套公密钥，将公钥添加到你要使用的 Git 平台账户下 1ssh-keygen -t rsa -C &quot;your email addr&quot; -f ~/.ssh/github 注意： -f 后面的参数是用来自定义 SSH KEY 的存放路径，如果不需要也可以自 -f 开始省略 命令输入完成后，连击3下回车就可以，不需要处理操作（除非你很想处理） 添加生成的 SSH 公钥添加 ssh 公钥到 github ** 打开 https://github.com/settings/profile ，选择 SSH and GPG keys 点击 New SSH key title 可以随便写，建议见名知意，能知道是哪台设备 key 通过刚刚通过 SSH 命令生成的 .pub 文件中复制即可。文件路径 .ssh/id_rsa.pub 异或是存在您 -f 之后指定的目录。 点击 add SSH key 配置多个 ssh配置多个 ssh 时，需要注意的是： 如果你未指定公钥的存储路径，那么你需要一个一个的手动去创建，并配置 ssh 公钥到对应平台，否则，后续的 ssh 创建过程， 会覆盖掉之前创建的。 ssh-keygen 会同时创建 id_rsa 和 id_rsa.pub 两个文件， .pub 是公钥， 不带后缀的是你的私钥。 同时配置多个 ssh 时，需要您保留私钥在 .ssh 目录下，为保证多平台都可以使用，您需要手动修改一下 id_rsa 文件的名称，.pub 就随便了，配置完，就没用了。 将密钥添加到 ssh-agent 中 1ssh-add ~.ssh/id_rsa 123456# 查看 agent 中的密钥ssh-add -l# 查看 agent 中的公钥ssh-add -L# 删除 agent 中的密钥ssh-add -d .ssh/id_xxx.pub 修改配置文件说了半天，终于到重点了 在 ~/.ssh 目录下新建一个 config 文件 对，没有错，就是一个连后缀都没有的文件，这个文件用来存储您的所有平台信息，以及平台对应使用的 ssh 密钥。 touch config 添加以下配置信息 12345678910111213# githubHost github.com # 也可以是数字 ip 地址，加不加 http/https 都无所谓HostName github.com # 同上PreferredAuthentications publickey # 这里不要修改IdentityFile ~/.ssh/id_rsa_github # 这里的文件名修改为该平台对应的密钥# gitlabHost 公司 gitlab 地址HostName 公司 gitlab 地址PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_gitlab... 测试命令为： 1ssh -T git@github.com 结果 1Hi boywithsmalleyes! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 只需要替换后面的 git仓库地址, 其他版本库都可以进行测试。 结语说了半天， 还是要记住一点，既然要使用 ssh 的方式进行版本管理，那么在 clone 代码时，也要使用 ssh 方式， 不然我说了这么半天，都是白扯。 文章内容有瑕疵，请给予指正批评]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 判断字符串是否是数字的方法]]></title>
    <url>%2F2019%2F04%2F16%2FJava-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用 Java自带的函数 12345678public static boolean isNumeric (String str) &#123; for (int i = str.length(); --i &gt;=0) &#123; if (!Character.isDigit(str.charAt(i))) &#123; return false; &#125; &#125; return true;&#125; 使用正则表达式 方法一: 1234public static boolean isNumeric(String str) &#123; Pattern pattern = Pattern.compile(&quot;^[-\\+]?[\\d]*$&quot;); return pattern.matcher(str).matches();&#125; 方法二: 123456public static boolean isNumeric(String str) &#123; if (str != null &amp;&amp; !&quot;&quot;.equals(str.trim())) &#123; return s.matches(&quot;^[0-9]*$&quot;); &#125; return false;&#125; 方法三: 1234 public static boolean isNumeric (String str) &#123; Pattern pattern = Pattern.compile(&quot;[0-9]*&quot;); return pattern.matcher(str).matcher();&#125; 使用 ASCII 码 123456789public static boolean isNumeric (String str) &#123; for (int i = str.length(); --i&gt;=0;) &#123; int chr = str.charAt(i); if (chr &lt; 48 || chr &gt; 57) &#123; return false; &#125; &#125; return true;&#125; 判断是不是浮点型数据 1234public static boolean isDouble(String str) &#123; Pattern pattern = Pattern.compile(&quot;^[-\\+]?[.\\d]*$&quot;); return pattern.matcher(str).matches();&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 中设置全屏的方法]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在开发中,我们经常需要把我们的应用设置为全屏,这里有两种方式: 一是在代码中设置; 二是在配置文件中设置 一. 在代码中设置1234567891011public class BaseActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(saveInstanceState); // 无title requestWindowFeature(Window.FEATURE_NO_TITLE); // 全屏 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.activity_main); &#125; &#125; 强调一点: 设置全屏的两段代码,必须在 setContentView() 之前调用,不然会报错 二. 在配置文件中修改1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.test&quot; android:versionCode=&quot;1&quot; ndroid:versionName=&quot;1.0&quot;&gt; &lt;application android:icon=&quot;@drawable/icon&quot; android:lable=&quot;@string/app_name&gt; &lt;activity android:name=&quot;.BaseActivity&quot; android:theme=&quot;@android:style/Theme.NotitleBar.Fullscreen&quot; android:lable=&quot;@string/app_name&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/application&gt;&lt;/manifest&gt; 使用第一种方法,会在应用运行后,看到一个短暂的状态来, 然后才全屏, 而第二种方法是不会有这种情况的,大家根据需要自行选择.]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 获取 IP 地址]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E8%8E%B7%E5%8F%96-IP-%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[开发中经常会需要判断当前是否连接网络, WiFi 或 移动数据连接判断的需求, 第一种方法: 123WifiManager wifiManager = (WifiManager) getSystemService(WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); 通过这种方式获取到的 IP 地址为一串数字,我们并不能看懂,因此我们需要通过下面的方法进行转换: 1String ip = (ipAddress &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;8 &amp; 0xff) + &quot;.&quot; + (ipAddress&gt;&gt;16 &amp; 0xff) + &quot;.&quot; + (ipAddress &gt;&gt; 24 &amp; 0xff); 这样转换之后,我们获取到的 IP 地址就是我们平时认识的, 比如: 192.168.1.108 这种方法在飞行模式下获取到的 IP 地址为 0.0.0.0 第二种方法: 12345678910111213141516 public String getLocalIpAddress() &#123; try &#123; for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) &#123; return inetAddress.getHostAddress().toString(); &#125; &#125; &#125; &#125; catch (SocketException ex) &#123; Log.e(LOG_TAG, ex.toString()); &#125; return null; &#125; 第二种方式是比较通用的,在WiFi和3G/4G 状态下,都可以获取到正确的地址.比如: fe80::8e3a:e3ff:fe45:a018 这种方法在手机处于飞行状态下时, 获取到的 IP 地址为 null]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件分发]]></title>
    <url>%2F2019%2F04%2F16%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[事件分发事件分发的三个方法 dispatchTouchEvent(MotionEvent event) 判断当前 View 是否要消费此事件，消费，则不再向下传递，反之传递，以此来分发事件； onInterceptTouchEvent(MotionEvent event) 通过 dispatchTouchEvent 调用， 返回值用来判断当前 View 是否要消费事件； onTouchEvent(MotionEvent event) 当 View 决定消费事件，则将进行该方法的调用，依据具体的事件，及具体业务，实现不同的事件。 关于事件分发的一些结论： 同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件系列以 down 事件开始， 中间含有若干个 move 事件， 最终以 up 事件结束； 正常情况下，一个事件序列只能被一个 View 拦截且消耗。这一套哦的原因可以参考 3， 因为一旦一个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个 View 同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件，通过 onTouchEvent强行传递给其他 View 处理； 某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果能传递到他的话），并且它的 onInterceptTouchEvent 不会再被调用。 某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent 返回 false）， 那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将会重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用，意思就是事件一旦交由一个 View 处理，那么它就必须消耗掉，否则同一事件序列中的剩下的事件就不在交给他来处理了。 如果 View 不消耗除 ACTION_DOWN 以外的其他事件， 那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续受到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。 ViewGroup 默认不拦截任何事件，Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。 View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给他，那么他的 onTouchEvent 方法就会被调用。 View 的 onTouchEvent 方法默认会消耗掉事件（返回 true），除非他是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都是 false，clickable 属性要分情况，比如 Button 的 clickable 属性默认是 true，而 TextView 的 clickable 默认未 false。 View 的 enable 属性不影响 onTouchEvent 的默认返回值，哪怕一个 View 是 disable 状态，只要他的 clickable 或者 longClickable 有一个为 true， 那么他的 onTouchEvent 就返回true。 onClick 会发生的前提是 View 是可点击的，并且它收到了 down 和 up 事件。 事件传递过程是有外向内的，即事件总是先传递给父元素，然后在由父元素分发给子 View，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外（解决滑动冲突，内部拦截法）。 事件的传递过程：Activity -&gt; Window(PhoneWindow) -&gt; View -&gt; dispatchTouchEvent -&gt; onInterceptTouchEvent -&gt; onTouchEvent。 当一个 View 需要处理事件时，如果它设置了 onTouchListener，那么 onTouchListener 中的 onTouch 方法会被回调。这时事件如何处理要看 onTouch 的返回值，返回 false，则当前 View 的 onTouchEvent 被调用，true， 则不调用。View 的 onTouchListener 方法优先级高于 onTouchEvent；onClickListener（需要完成有 up 操作） 方法在 onTouchEvent 中被调用，因此，onClickListener 处于事件传递的尾端。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 在一个应用中启动另外一个应用]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Android 在一个应用中启动另外一个应用Android 中,从当前 APP 启动另外一个 APP 的需求,不是很常见, 但确实存在着,比如说在某宝还没有现在这么强大时,支付需要启动他们的 APP. 再比如说,某米的钱包系统,需要和他们的金融 APP 在某些业务上是相互依赖的,需要相互启动. 综上所述, 从一个 APP 去启动另外一个 APP 的需求还是有它存在的价值.因此,一下是我在工作和学习中总结的如何通过一个 APP 去启动另外一个 APP 的方式. 1. 通过 APP 启动另一个 APP1234String packageName = &quot;com.android.calendar&quot;;Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);intent.putExtra(&quot;type&quot;, true);startActivity(intent); 上面的代码,就可以完成从一个 APP 启动另一个 APP 的业务需求, 这里需要注意的是,我们需要检测一下要启动的 APP 是否已经安装,如果应用未安装, 则会 NullPointException. 通过这种方式, Android 虚拟机会自己在目标 APP 下寻找标签为 android.intent.action.MAIN 的 Activity 启动. 这里介绍两种方式,检测目标应用是否已经安装 方法一: 1234Intent intent = getPackageName().getLaunchIntentForPackage(packageName);if (intent == null) &#123; // 这里判断 Intent 为空, 说明应用不存在 &#125; 方法二: 1234PackageInfo packageInfo = getPackageManager(0.getPackageInfo(packageName, 0);if (packageInfo == null) &#123; // 这里如果 packageInfo 为 null, 说明应用不存在&#125; 2. 打开另外一个 APP 指定的 Activity1234Intent intent = new Intent();ComponentName componeneName = new ComponeneName(&quot;com.android.calendar&quot;, &quot;com.android.calendar.LaunchActivity&quot;);intent.setComponent(componeneName);startActivity(intent); 值得注意: 需要将目标 Activity 的 android:export=”true” 属性在所属应用的 AndroidMainfest 里设置为 true, 意思是当前 Activity 允许被外部应用访问, 否则会报错 123Caused by: java.lang.SecurityException: Permission Denial: starting Intent &#123; cmp=com.example.fm/.MainFragmentActivity (has extras) &#125; from ProcessRecord&#123;39282a97 11545:com.xing.toolbardemo1/u0a71&#125; (pid=11545, uid=10071) not exported from uid 10067 在 5.0 以前的设备上,需要在当前的 AndroidMainfest 里也生命目标Activity, 否则会报错; 但在 5.0 以后的设备上,就不会报错哦 12 Caused by: android.content.ActivityNotFoundException: Unable to find explicit activity class &#123;com.example.fm/com.example.fm.MainFragmentActivity&#125;; have you declared this activity in your AndroidManifest.xml?]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio Dependencies Library Resolve]]></title>
    <url>%2F2019%2F04%2F16%2FAndroid-Studio-Dependencies-Library-Resolve%2F</url>
    <content type="text"><![CDATA[在使用 Android Studio 开发时,使用 Gradle 脚本构建项目, 同 Maven 一样,所引用的包之间也存在着相互依赖的关系, 当你使用某个包之后,发现有包版本冲突, 那么解决方案就来了. 先说点不正经的: 你可以把你自己引入的包去掉,使用依赖包 放弃治疗 哈哈,言归正传: 当我们引入的包之间存在冲突(不是同一个)的关系时, 也就是说,我们需要保留一个项目依赖包使用,那么我们需要在 build.gradle 中将我们不需要的包删除掉. 举个栗子:当我使用 com.squareup.retrofit2:adapter-rxjava:2.1.0 时, 它默认依赖使用 RxJava 1.5.0 版本. 当我使用 io.reactivex.rxjava2:rxjava:2.0.6 时, 就会引起包冲突. 解决方案:build.gradle 1234567891011...dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) compile (&apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;)&#123; exclude group: &apos;io.reactivex&apos; &#125; compile &apos;io.reactivex.rxjava2:rxjava:2.0.6&apos; compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git command]]></title>
    <url>%2F2019%2F04%2F16%2Fgit-command%2F</url>
    <content type="text"><![CDATA[Git 命令 修改记录 修改时间 备注 添加删除远程分支 2018年07月26日13:59:22 删除远程分支命令 更新fork仓库 2018年08月10日14:16:08 添加fork的仓库，从主仓库更新代码的命令 整理的还不够完善，以后工作中遇到了会不断补进，如有大神，有可以留言，我们一起来完善。欢迎各位留言^_^ Git 文件的三种状态 已提交：表示该文件已经被安全地保存在本地版本库中，执行过git commit。 已修改：表示修改了某个文件，但还没有提交保存 已暂存：表示把已修改的文件房子啊下次提交时要保存的清单中，也就是执行了 git add 命令。 远程仓库与本地代码的配置将本地已经有的项目上传到远程空仓库中 123456cd &lt;project path&gt;git initgit remote add origin &lt;远程仓库地址&gt;git add .git commit -m &apos;提交日志&apos;git push -u origin master Git 基本配置 配置个人的用户名称和电子邮件地址，每次提交时，都会引用这两条信息，以用来说明是谁提交的更新。 使用 --global 选项，更改的未用户主目录下的配置，如果想在某个特定的项目中使用其他的名称和邮件，只需要去掉 --global 选项重新配置，新的配置位于当前项目的 .git/config 文件中。 12git config --global user.name &apos;&apos;yourname&apos;&apos;git config --global user.email yourname@gmail.com 基础命令 git init 通过此命令会在当前目录创建一个.git的隐藏目录，这是git的第一步。 git status git status是最为常用的命令之一，用于检查本地项目的状态.仔细阅读红色/绿色部分，可以获得相关文件的操作信息，根据提示，判断是执行git commit 还是执行git add 操作。 git add 将一个或多个文件添加到 git仓库中，只有通过 git add 添加的文件才会被版本控制管理。 添加单个文件 git add HelloWorld2.java 添加多个文件 git add --a 添加当前目录所有文件 git add . git rm –cached 将文件从git追踪列表中移除，只是逻辑删除（从版本库中移除），并不会将本地文件删除 git commit 执行过 git add 命令后，需要将暂存的文件提交到本地仓库中，此时是真正的提交 带 log 的提交： git commit -m &#39;first commit&#39; 通过编辑器提交: git commit 带log 的提交比较方便，但当你的提交信息有一定格式或者需要提交的文字内容较多时，使用编辑器效果会更好. git log 查看历史提交记录， 包括提交人、时间、信息、信息指纹等. 查看提交记录： git log 单行展示记录： git log --pretty=oneline 展示全部信息： git log --pretty=fuller git clone &lt;远程仓库地址&gt; 拉取远程仓库代码,此项目并不一定是你所创建 例如： git clone git@github.com:bboyfeiyu/AndroidEventBus.git 执行完成后，会在本地当前目录创建一个AndroidEventBus的目录来存放仓库代码 git remote 将本地已经init过的工程链接到远程的空仓库中，以此来完成远程版本库的创建 链接远程版本库： git remote add origin &lt;远程地址&gt; git branch 分支是用来管理代码版本、类型的有效工具，可根据不同的服务对象、不同的上线版本等等，来做代码分离，版本管理操作 查看分支： git branch 查看带提交信息的分支信息： git branch -v 创建分支： git branch &lt;分支名称&gt; 创建并切换分支： git branch -b &lt;分支名称&gt; 切换分支： git checkout &lt;分支名称&gt; 推送分支： git push origin &lt;分支名称&gt; 删除分支： git branch -d &lt;分支名称&gt; 删除远程分支： git push origin :&lt;分支名称&gt; 合并分支： git merge &lt;分支名称&gt; git tag 会列出所有的 tag 标签信息 在完成了所有功能、并且经过测试之后，可以封板上线的版本，通常会打一个标签，这是一个很重要的功能 建议每次上线都要做一次，便于后续的版本检索与维护，通常一个标签就代表了一个正式版本。 查看本地/远程 tag 标签：git tag 查看模糊 tag 标签： git tag -l &#39;v1.4.2.*&#39; 查看备注 tag 标签： git tag -ln 查看标签信息： git show &lt;标签名&gt; 创建本地 tag 标签： git tag -a &lt;标签名&gt; -m &quot;&lt;标签备注信息&gt;&quot; 删除本地 tag 标签： git tag -d &lt;标签名&gt; 推送远程 tag 标签： git push origin &lt;标签名&gt; 推送全部 tag 标签： git push origin -tags 删除远程 tag 标签： git push origin :refs/tags/&lt;标签名&gt; 查看远程机状态 git remote 用来管理， fork 的项目，与主项目的更新操作 12345git remote -vgit remote add upstream git@github.com:XXX/XXX.gitgit fetch upstreamgit merge upstream/mastergit push 使用中的一些技巧命名别名复杂并超长的命令，可以通过起别名的方式方便在终端中书协 123git config --global alias.ci commitgit config --global alias.ck checkoutgit config --global alias.st status 然后就可以很愉快的使用git命令了。1git st]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个Android IoT App]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAndroid-IoT-App%2F</url>
    <content type="text"><![CDATA[构建 Android IoT App本文翻译自Building IoT APP for Android Things in 3 step 前言这篇文章主要描述了，如何为 Android Things 构建 Android IoT App。 也许你早已经知道了，最近 Google 发布了一个新的 IoT 操作系统– Android Things。Android Things 系统，是由 Android 系统衍生出来的，更有意思的是，我们可以使用我们的 Android 知识来开发 Android IoT 应用程序。在开始之前，了解 Android Things and how it works 是很有必要的。 名词索引Android IoT App ： 安卓物联网应用 Raspberry Pi 3 ： 树莓派 3 目标这篇文章的目标是： 使用 Android Things 构建一个简单的 RGB Led 控制器 使用 Android API 构建 Android IoT UI 开发 我们会使用 Raspberry Pi 3 作为 IoT 开发板,你也可以使用其他的开发板去开发 Android Things。 此Android IoT应用可帮助您熟悉新的Android Things API。 此外，这个物联网应用程序对于开发Android IoT 应用 UI 的概述很有用。 步骤一通常情况下，一个 IoT 工程有两部分， 电气/电子部分和软件部分。让事情变得简单，使我们可以集中精力在Android IoT App, 这个 IoT 应用控制着一个简单的 RGB LED （共阳极）灯。RGB Led 灯使用220Ω电阻链接到 Raspberry， 每个颜色一个，原理图如下： 共阳极 RGB LED 灯非常常见，因此 Raspberry Pi 3 为引脚阳极供电。控制 LED 颜色的 RGB 引脚连接到 Raspberry 引脚： Pin 29 Pin 31 Pin 33 这些引脚索引是非常重要的，因为我们会在 Android IoT App 上使用它。 上电前，请仔细检查 Raspberry 链接是否有异常。 现在，我们使用 Android Studio 创建一个 IoT 应用，第一步，配置 Android IoT 工程， build.gradle : 123dependencies &#123; provided &apos;com.google.android.things:androidthings:0.1-devpreview&apos;&#125; Android Things 使用 Activity ，就像我们在 Android 中使用一样。因此，让我们创建一个 RGBThingsActivity 类，并在 onCreate 方法中处理 Pin 通信。 步骤二使用 GPIO 引脚与 RGB LED 传递信息。 GPIO 引脚使用可编程的接口去获取设备的状态或者设置输出值（高电平/低电平），使用 Respberry GPIO 音及哦啊，我们开启或关闭三个颜色的组件（红绿蓝）。 Android Things SDK 提供了一个 PeripheralManagerService 的服务，去抽象 GPIO 通信接口。每当我们想读写数据时都必须使用它。一开始， Android IoT App 初始化服务，并设置引脚值： 1234567891011121314try &#123; PeripheralManagerService manager = new PeripheralManagerService(); blueIO = manager.openGpio(&quot;BCM5&quot;); blueIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); greenIO = manager.openGpio(&quot;BCM6&quot;); greenIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_HIGH); redIO = manager.openGpio(&quot;BCM13&quot;); redIO.setDirection(Gpio.DIRECTION_OUT_INITIALLY_LOW); redIO.setValue(false); blueIO.setValue(false); greenIO.setValue(false);&#125; catch (IOException e) &#123; Log.w(TAG, &quot;Unable to access GPIO&quot;, e);&#125; 这段代码介绍了一些新的重要的新方面。首先,我们必须选对引脚。如果使用的是 Respberry ，我们需要知道每一个引脚都有对应的序号。同样的方式，Android Things 使用相同的寻址模型，不管怎样，引脚的命名都是用不同的方式。通过 Respberry Pin reference ,下图： 可以了解到 Respberry Pi 3 的引脚地址。这些地址名称在上面的代码中使用。 例如，要使用引脚BCM5（或引脚29），代码为： 1blueIO = manager.openGpio(&quot;BCM5&quot;); 开始， 我们设置所有的引脚为低电平状态（低电平即为关闭状态），此时 Led 灯为关闭状态。改变引脚的状态值，由低电平调整到高电平，或者有高电平调整为低电平，我们可以看到灯的颜色变化。 步骤三Android Things 另外一个有趣的功能是，为我们提供了 UI Interface。 我们开发一个 UI Interface 给 Android IoT App 和开发 Android UI 一样。就像 Android app 一样， Android Things UI 同样是使用 xml 格式开发。 下面例子，我们去配置控制 RGB Led 显示的 3 个开关： 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Switch android:text=&quot;Red&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchRed&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;Switch android:text=&quot;Green&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchGreen&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;Switch android:text=&quot;Blue&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/switchBlue&quot; android:layout_marginTop=&quot;20dp&quot;/&gt; &lt;/LinearLayout&gt; 在 onCreate 方法中，我们设置 layout 布局： 123456@Overridepublic void onCreate (Bundle savedInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ...&#125; 处理用户开关： 1234567891011Switch switchRed = (Switch)findViewById(R.id.switchRed);switch.setOnCheckedChangedListener(new CompoundButton.OnCheckedChangedListener()&#123; @Override public void onCheckedChanged (CompoundButton buttonView, boolean isChecked)&#123; try &#123; redIO.setValue(!isChecked); &#125; catch (IOException e) &#123; Log.w(TAG,&quot;Red GPIO Error&quot;, e); &#125; &#125;&#125;); 我们必须为其他引脚重复同一段代码。最终结果如下： 因 MarkDown 模式下， 简书不支持视频播放，请点击一下链接观看。 最终结果展示–需要翻墙 youtube 上观看 最后，要使用我们的应用程序，我们必须在 Manifest.xml 文件中条件： 1&lt;uses-library android:name=&quot;com.google.android.things&quot;/&gt; 并且声明我的 Activity 是一个 IoT Activity， 启动脚本为： 1234&lt;intent-filter&gt; &lt;category android:name=&quot;android.intent.category.IOT_LAUNCHER&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT”/&gt;&lt;/intent-filter&gt; 总结文章最后，你已经知道了如何更好的使用 Android Things。 有趣的是，使用一些新的 API Android 开发人员可以准备下一次技术革命成为物联网。此外，开发过程与 Android 应用程序相同。 使用简单的几行代码，一个 Android 开发者就可以构建 Android IoT App.]]></content>
      <tags>
        <tag>Android Things</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins + gradle + git 构建 Android CI 构建环境]]></title>
    <url>%2F2019%2F04%2F16%2FJenkins-gradle-git-%E6%9E%84%E5%BB%BA-Android-CI-%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言在项目开发中，我们需要将最新的代码更新，提供给测试人员进行测试，以及发布。 目前 Android 工作中都在使用很强大的开发、构建以及打包工具，例如： android-studio、Gradle、Git等。 然，在企业组织并不是很完善的公司里，开发打包发布等工作，时常会由开发人员进行操作，难免在一些地方疏忽掉。 因此，CI 构建的出现，使得这些繁琐的工作变得轻松起来。 对于开发工程师，只负责向版本库提交代码，不用关心打包，发布之类的流程。 对于产品和测试，只需要从发布页面下载 APK 安装文件，不需要每一次都去工程师哪里索取最新的安装文件。 CI 的基本工作流程如下： 我们每一次提交代码（通过git/svn作为版本库）到主干上，根据 CI 的定时任务，检测到版本更新，通过 CI ，将进行打包发布等流程操作。 准备工作本文使用 Linux Ubuntu 系统为大家介绍环境的搭建 环境工具1. PC 机(mac/linux) 2. Java JDK 3. Android SDK 4. Gradle 5. Git 6. Tomcat 7. Jenkins 环境搭建Java 环境 安装Java JDK, Android SDK, Gradle 可从AndroidDevTools处下载获取。 git 安装git 可通过终端进行安装123sudo add-apt-repository ppa:git-core/ppasudo apt-get updatesudo apt-get install git 安装完成之后通过git --version 检查是否成功 安装后 git 存储在 /usr/bin/git下 Jenkins通过 Jenkins 官方网站下载最新Jenkins.war包 环境变量打开 vi /etc/profile 将下列语句添加在文件的末尾后， 执行 esc-&gt;:wq 其中环境位置根据自己的所在位置进行相应的更改 启动激动的你，是不是已经被这些繁琐的东西搞的不耐烦了呢，下面我们开始启动 Jenkins 将下载好的 Jenkins.war 包， 放入 Tomcat 的 webapps 目录下，进入 bin 目录执行 ./startup.sh 启动 Tomcat。 启动后，在浏览器中输入： localhost:8080/jenkins 插件安装系统管理-&gt; 插件管理-&gt;可选插件： 在搜索框中搜索以下插件，并进行安装 git plugingitlab plugingrade pluginAndroid Lint PluginBuild Pipeline pluginbuild timeout pluginbuild name pluginchange assembly-version plugincredentials binding plugindescription setter pluginDynamic parameter pluginEmail Extension pluginFindBugs pluginJaCoco pluginUnit attachments pluginProject Description pluginTimestamperWorkspace cleanup plugin 安装完成后，重启。 系统设置系统管理-&gt;系统设置： 配置Android 环境，将地址指向本机的 SDK 目录 系统管理-&gt;全局工具配置 配置 Java， Git ， Gradle 目录等 JDK： Git： Gradle： 到此，环境配置，已基本完成。 下面我们开始进行项目够将操作 项目构建创建Job新建-&gt;构建一个自由风格的软件项目: 参数化构建通常我们在使用 Android-studio 进行打包时以及签名时，都会用到build.gradle并在其中配置相关属性。再此，我们可以用Jenkins，配置我们的项目参数，例如发布的版本号，构建时间， 上传路径，发布地址，签名打包等等。 在这里我们先看看 build.gradle 中的构建信息: 在项目的 moudle 下 build.gradle 文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def getDate () &#123; def date = new Date() def formattedDate = date.format(&quot;yyyyMMddHHmm&quot;) return formattedDate&#125;def verName = APP_VERSIONdef verCode = 14android &#123; .... signingConfigs &#123; release &#123; keyAlias &apos;&apos; keyPassword &apos;&apos; storeFile file (&apos;&apos;) storePassword &apos;&apos; &#125; &#125; defaultConfig &#123; applicationId &quot;cn.zhuangbudong.example&quot; minSdkVersion 18 targetSdkVersion 25 multiDexEnabled true versionCode verCode versionName verName resValues(&quot;string&quot;, &apos;app_version&apos;, verName) &#125; buildTypes &#123; release &#123; signingConfig signingConfigs.release minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; lintOptions &#123; abortOnError false &#125; dexOptions &#123; javaMaxHeapSize &apos;2g&apos; &#125;applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def newName def timeNow def oldFile = output.outputFile def outDirectory = oldFile.parent if (&quot;true&quot;.equals(IS_JENKINS)) &#123; timeNow = JENKINS_TIME outDirectory = &quot;/media/nexd/work/android/package/release/&quot; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; &#125; else &#123; timeNow = getDate() if (variant.buildType.name.equals(&apos;debug&apos;)) &#123; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_debug.apk&quot; &#125; else &#123; newName = &apos;zhuangbudong_example_&apos; + verName + &quot;_&quot; + timeNow + &quot;_&quot; + variant.buildType.name + &quot;.apk&quot; &#125; &#125; output.outputFile = new File(outDirectory, newName) &#125;&#125; &#125;&#125; gradle.properties: 123APP_VERSION=2.0.2IS_JENKINS=falseJENKINS_TIME=&apos;&apos; 在工程中添加以上代码，并在Jenkins中为这些参数赋值。 下面介绍 Jenkins 参数配置 勾选参数化构建过程，如下图： 按照下图，添加相关类型的参数，此处注意，Jenkins 配置的参数名要和在android-studio中配置的参数名保持一致 源码管理此处负责从版本库中拉去最新的代码 此处如果需要验证，点击 Add， 选择： Username with password 在对应窗口输入用户名和密码信息 点击添加。 使用 gitlab 进行源码库管理。 触发器触发器负责拉取代码，编译，打包，发布等操作。通过触发器，执行Jenkins。 构建环境此处只是在Jenkins在打包时，配置任务名称即可。如下图： 构建这里是最重要滴，配置以下命令，才能进行打包签名等等。 如下配置，这里需要注意下，构建文件，根目录。在你的目录结构比较复杂的时候，即你的根目录没有 build.gradle 文件时，需要指定一下 build.gradle 目录的位置。 同时，也是最重要的，勾选上pass job parameters as gradle properties ，不然之前配置的参数无法传递给项目中的 gradle.properties。 构建后操作当项目构建完成后，我们可以通过邮件的方式将产生的Apk文件，以及测试报告，构建日志等信息，发送出来 如下图： 12345678910111213&lt;hr/&gt;(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;项目名称：$&#123;PROJECT_NAME&#125;&lt;br/&gt;&lt;hr/&gt;构建编号：$&#123;BUILD_NUMBER&#125;&lt;br/&gt;&lt;hr/&gt;构建状态：$&#123;BUILD_STATUS&#125;&lt;br/&gt;&lt;hr/&gt;触发原因：$&#123;CAUSE&#125;&lt;br/&gt;&lt;hr/&gt;测试报告：&lt;a href=&quot;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&quot;&gt;$&#123;PROJECT_URL&#125;ws/$&#123;PROJECT_NAME&#125;app/build/reports/tests/release/index.html&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建日志地址：&lt;a href=&quot;$&#123;BUILD_URL&#125;console&quot;&gt;$&#123;BUILD_URL&#125;console/&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建地址：&lt;a href=&quot;$&#123;PROJECT_URL&#125;&quot;&gt;$&#123;PROJECT_URL&#125;&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;构建报告：&lt;a href=&quot;$&#123;BUILD_URL&#125;testReport&quot;&gt;$&#123;BUILD_URL&#125;testReport&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;变更集:$&#123;JELLY_SCRIPT,template=&quot;html&quot;&#125;&lt;br/&gt;&lt;hr/&gt; 开始构建回到 Jenkins 首页，点击创建的项目，点击 build with parameters: 点击开始构建，启动 Jenkins 构建任务。 构建成功时，显示为蓝色， 失败为红色，如下图： 构建后生成的 Apk 文件，存在 build.gradle 文件中配置的目录。同时也可以使用蒲公英或fir.im 进行发布管理。 谢谢~]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb command]]></title>
    <url>%2F2019%2F04%2F16%2Fadb-command%2F</url>
    <content type="text"><![CDATA[查看PID 1adb shell ps 查看日志 12345全部日志adb logcat按照 PID 筛选日志adb logcat | grep &lt;PID&gt; 查询链接设备 1adb devices 重启机器 1adb reboot 杀死进程服务 1adb kill-server 重启进程服务 1adb start-server 获取机器 Mac 地址 1adb shell cat /sys/class/net/wlan0/address 安装 APK 12345678普通安装adb install &lt;file path&gt;保留数据和缓存文件adb install -r &lt;file path&gt;安装到 SD 卡上adb install -s &lt;file path&gt; 卸载 APK 12345普通卸载adb uninstall &lt;package name&gt;保留数据和缓存文件adb uninstall -k &lt;package name&gt; 启动应用 1adb shell am start -n &lt;package name&gt;/.&lt;activity_class_name&gt; 查看 CPU 占用率 1234567adb shell top查看内存占用前 6 的 appadb shell top -m 6刷新一次内存adb shell top -n 1 杀死进程 1adb shell kill &lt;pid&gt; 将 System 分区重新挂在为可读写分区 1adb remount 从本地复制文件到设备 1adb push &lt;local&gt; &lt;remote&gt; 从设备复制文件到本地 1adb pull &lt;remote&gt; &lt;local&gt; 查看 WiFi 密码 1adb shell cat /data/misc/wifi/*.conf 查看 bug 报告 1adb bugreport 跑 monkey 1adb shell monkey -v -p your.package.name 500 截图 1adb shell screencap -p /sdcard/screenshot.png 录屏 1adb shell screenrecord /sdcard/demo.mp4 查看安装列表 1adb shell pm list packages]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[schedule]]></title>
    <url>%2Fschedule%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[sitemap]]></title>
    <url>%2Fsitemap%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
